'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import BorshPubkey
from construct import Container
from dataclasses import dataclass
from solders.pubkey import Pubkey as SolPubkey
from . import aggregatorRound, hash, switchboardDecimal

class AggregatorAccountDataJSON(typing.TypedDict):
    name: list[int]
    metadata: list[int]
    authorWallet: str
    queuePubkey: str
    oracleRequestBatchSize: int
    minOracleResults: int
    minJobResults: int
    minUpdateDelaySeconds: int
    startAfter: int
    varianceThreshold: switchboardDecimal.SwitchboardDecimalJSON
    forceReportPeriod: int
    expiration: int
    consecutiveFailureCount: int
    nextAllowedUpdateTime: int
    isLocked: bool
    schedule: list[int]
    latestConfirmedRound: aggregatorRound.AggregatorRoundJSON
    currentRound: aggregatorRound.AggregatorRoundJSON
    jobPubkeysData: list[str]
    jobHashes: list[hash.HashJSON]
    jobPubkeysSize: int
    jobsChecksum: list[int]
    authority: str
    ebuf: list[int]

@dataclass
class AggregatorAccountData:
    layout: typing.ClassVar = borsh.CStruct(
        "name" /borsh.U8[32],
        "metadata" /borsh.U8[128],
        "authorWallet" /BorshPubkey,
        "queuePubkey" /BorshPubkey,
        "oracleRequestBatchSize" /borsh.U32,
        "minOracleResults" /borsh.U32,
        "minJobResults" /borsh.U32,
        "minUpdateDelaySeconds" /borsh.U32,
        "startAfter" /borsh.I64,
        "varianceThreshold" /switchboardDecimal.SwitchboardDecimal.layout,
        "forceReportPeriod" /borsh.I64,
        "expiration" /borsh.I64,
        "consecutiveFailureCount" /borsh.U64,
        "nextAllowedUpdateTime" /borsh.I64,
        "isLocked" /borsh.Bool,
        "schedule" /borsh.U8[32],
        "latestConfirmedRound" /aggregatorRound.AggregatorRound.layout,
        "currentRound" /aggregatorRound.AggregatorRound.layout,
        "jobPubkeysData" /BorshPubkey[16],
        "jobHashes" /hash.Hash.layout[16],
        "jobPubkeysSize" /borsh.U32,
        "jobsChecksum" /borsh.U8[32],
        "authority" /BorshPubkey,
        "ebuf" /borsh.U8[224],
        )
    #fields
    name: list[int]
    metadata: list[int]
    authorWallet: SolPubkey
    queuePubkey: SolPubkey
    oracleRequestBatchSize: int
    minOracleResults: int
    minJobResults: int
    minUpdateDelaySeconds: int
    startAfter: int
    varianceThreshold: switchboardDecimal.SwitchboardDecimal
    forceReportPeriod: int
    expiration: int
    consecutiveFailureCount: int
    nextAllowedUpdateTime: int
    isLocked: bool
    schedule: list[int]
    latestConfirmedRound: aggregatorRound.AggregatorRound
    currentRound: aggregatorRound.AggregatorRound
    jobPubkeysData: list[SolPubkey]
    jobHashes: list[hash.Hash]
    jobPubkeysSize: int
    jobsChecksum: list[int]
    authority: SolPubkey
    ebuf: list[int]
    
    @classmethod
    def from_decoded(cls, obj: Container) -> "AggregatorAccountData":
        return cls(
        name=obj["name"],
        metadata=obj["metadata"],
        authorWallet=obj["authorWallet"],
        queuePubkey=obj["queuePubkey"],
        oracleRequestBatchSize=obj["oracleRequestBatchSize"],
        minOracleResults=obj["minOracleResults"],
        minJobResults=obj["minJobResults"],
        minUpdateDelaySeconds=obj["minUpdateDelaySeconds"],
        startAfter=obj["startAfter"],
        varianceThreshold=switchboardDecimal.SwitchboardDecimal.from_decoded(obj["varianceThreshold"]),
        forceReportPeriod=obj["forceReportPeriod"],
        expiration=obj["expiration"],
        consecutiveFailureCount=obj["consecutiveFailureCount"],
        nextAllowedUpdateTime=obj["nextAllowedUpdateTime"],
        isLocked=obj["isLocked"],
        schedule=obj["schedule"],
        latestConfirmedRound=aggregatorRound.AggregatorRound.from_decoded(obj["latestConfirmedRound"]),
        currentRound=aggregatorRound.AggregatorRound.from_decoded(obj["currentRound"]),
        jobPubkeysData=list(map(lambda item:SolPubkey.from_string(item),obj["jobPubkeysData"])),
        jobHashes=list(map(lambda item:hash.Hash.from_json(item),obj["jobHashes"])),
        jobPubkeysSize=obj["jobPubkeysSize"],
        jobsChecksum=obj["jobsChecksum"],
        authority=obj["authority"],
        ebuf=obj["ebuf"],
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
                "name": self.name,
                "metadata": self.metadata,
                "authorWallet": self.authorWallet,
                "queuePubkey": self.queuePubkey,
                "oracleRequestBatchSize": self.oracleRequestBatchSize,
                "minOracleResults": self.minOracleResults,
                "minJobResults": self.minJobResults,
                "minUpdateDelaySeconds": self.minUpdateDelaySeconds,
                "startAfter": self.startAfter,
                "varianceThreshold": self.varianceThreshold.to_encodable(),
                "forceReportPeriod": self.forceReportPeriod,
                "expiration": self.expiration,
                "consecutiveFailureCount": self.consecutiveFailureCount,
                "nextAllowedUpdateTime": self.nextAllowedUpdateTime,
                "isLocked": self.isLocked,
                "schedule": self.schedule,
                "latestConfirmedRound": self.latestConfirmedRound.to_encodable(),
                "currentRound": self.currentRound.to_encodable(),
                "jobPubkeysData": self.jobPubkeysData,
                "jobHashes": self.jobHashes,
                "jobPubkeysSize": self.jobPubkeysSize,
                "jobsChecksum": self.jobsChecksum,
                "authority": self.authority,
                "ebuf": self.ebuf,
                }

    def to_json(self) -> AggregatorAccountDataJSON:
        return {
                "name": self.name,
                "metadata": self.metadata,
                "authorWallet": str(self.authorWallet),
                "queuePubkey": str(self.queuePubkey),
                "oracleRequestBatchSize": self.oracleRequestBatchSize,
                "minOracleResults": self.minOracleResults,
                "minJobResults": self.minJobResults,
                "minUpdateDelaySeconds": self.minUpdateDelaySeconds,
                "startAfter": self.startAfter,
                "varianceThreshold": self.varianceThreshold.to_json(),
                "forceReportPeriod": self.forceReportPeriod,
                "expiration": self.expiration,
                "consecutiveFailureCount": self.consecutiveFailureCount,
                "nextAllowedUpdateTime": self.nextAllowedUpdateTime,
                "isLocked": self.isLocked,
                "schedule": self.schedule,
                "latestConfirmedRound": self.latestConfirmedRound.to_json(),
                "currentRound": self.currentRound.to_json(),
                "jobPubkeysData": list(map(lambda item:str(item),self.jobPubkeysData)),
                "jobHashes": list(map(lambda item:item.to_json(),self.jobHashes)),
                "jobPubkeysSize": self.jobPubkeysSize,
                "jobsChecksum": self.jobsChecksum,
                "authority": str(self.authority),
                "ebuf": self.ebuf,
                }

    @classmethod
    def from_json(cls, obj: AggregatorAccountDataJSON) -> "AggregatorAccountData":
        return cls(
                name=obj["name"],
                metadata=obj["metadata"],
                authorWallet=SolPubkey.from_string(obj["authorWallet"]),
                queuePubkey=SolPubkey.from_string(obj["queuePubkey"]),
                oracleRequestBatchSize=obj["oracleRequestBatchSize"],
                minOracleResults=obj["minOracleResults"],
                minJobResults=obj["minJobResults"],
                minUpdateDelaySeconds=obj["minUpdateDelaySeconds"],
                startAfter=obj["startAfter"],
                varianceThreshold=switchboardDecimal.SwitchboardDecimal.from_json(obj["varianceThreshold"]),
                forceReportPeriod=obj["forceReportPeriod"],
                expiration=obj["expiration"],
                consecutiveFailureCount=obj["consecutiveFailureCount"],
                nextAllowedUpdateTime=obj["nextAllowedUpdateTime"],
                isLocked=obj["isLocked"],
                schedule=obj["schedule"],
                latestConfirmedRound=aggregatorRound.AggregatorRound.from_json(obj["latestConfirmedRound"]),
                currentRound=aggregatorRound.AggregatorRound.from_json(obj["currentRound"]),
                jobPubkeysData=list(map(lambda item:SolPubkey.from_string(item),obj["jobPubkeysData"])),
                jobHashes=list(map(lambda item:hash.Hash.from_json(item),obj["jobHashes"])),
                jobPubkeysSize=obj["jobPubkeysSize"],
                jobsChecksum=obj["jobsChecksum"],
                authority=SolPubkey.from_string(obj["authority"]),
                ebuf=obj["ebuf"],
        )






