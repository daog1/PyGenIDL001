'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;
from solders.sysvar import RENT;
from . import switchboardDecimal;

class AggregatorRoundJSON(typing.TypedDict):
    numSuccess: int
    numError: int
    isClosed: bool
    roundOpenSlot: int
    roundOpenTimestamp: int
    result: switchboardDecimal.SwitchboardDecimalJSON
    stdDeviation: switchboardDecimal.SwitchboardDecimalJSON
    minResponse: switchboardDecimal.SwitchboardDecimalJSON
    maxResponse: switchboardDecimal.SwitchboardDecimalJSON
    oraclePubkeysData: list[str]
    mediansData: list[switchboardDecimal.SwitchboardDecimalJSON]
    currentPayout: list[int]
    mediansFulfilled: list[bool]
    errorsFulfilled: list[bool]

@dataclass
class AggregatorRound:
    layout: typing.ClassVar = borsh.CStruct(
        "numSuccess" /borsh.U32,
        "numError" /borsh.U32,
        "isClosed" /borsh.Bool,
        "roundOpenSlot" /borsh.U64,
        "roundOpenTimestamp" /borsh.I64,
        "result" /switchboardDecimal.SwitchboardDecimal.layout,
        "stdDeviation" /switchboardDecimal.SwitchboardDecimal.layout,
        "minResponse" /switchboardDecimal.SwitchboardDecimal.layout,
        "maxResponse" /switchboardDecimal.SwitchboardDecimal.layout,
        "oraclePubkeysData" /BorshPubkey[16],
        "mediansData" /switchboardDecimal.SwitchboardDecimal.layout[16],
        "currentPayout" /borsh.I64[16],
        "mediansFulfilled" /borsh.Bool[16],
        "errorsFulfilled" /borsh.Bool[16],
        )
    #fields
    numSuccess: int
    numError: int
    isClosed: bool
    roundOpenSlot: int
    roundOpenTimestamp: int
    result: switchboardDecimal.SwitchboardDecimal
    stdDeviation: switchboardDecimal.SwitchboardDecimal
    minResponse: switchboardDecimal.SwitchboardDecimal
    maxResponse: switchboardDecimal.SwitchboardDecimal
    oraclePubkeysData: list[SolPubkey]
    mediansData: list[switchboardDecimal.SwitchboardDecimal]
    currentPayout: list[int]
    mediansFulfilled: list[bool]
    errorsFulfilled: list[bool]
    
    @classmethod
    def from_decoded(cls, obj: Container) -> "AggregatorRound":
        return cls(
        numSuccess=obj["numSuccess"],
        numError=obj["numError"],
        isClosed=obj["isClosed"],
        roundOpenSlot=obj["roundOpenSlot"],
        roundOpenTimestamp=obj["roundOpenTimestamp"],
        result=switchboardDecimal.SwitchboardDecimal.from_decoded(obj["result"]),
        stdDeviation=switchboardDecimal.SwitchboardDecimal.from_decoded(obj["stdDeviation"]),
        minResponse=switchboardDecimal.SwitchboardDecimal.from_decoded(obj["minResponse"]),
        maxResponse=switchboardDecimal.SwitchboardDecimal.from_decoded(obj["maxResponse"]),
        oraclePubkeysData=list(map(lambda item:SolPubkey.from_string(item),obj["oraclePubkeysData"])),
        mediansData=list(map(lambda item:switchboardDecimal.SwitchboardDecimal.from_json(item),obj["mediansData"])),
        currentPayout=obj["currentPayout"],
        mediansFulfilled=obj["mediansFulfilled"],
        errorsFulfilled=obj["errorsFulfilled"],
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
                "numSuccess": self.numSuccess,
                "numError": self.numError,
                "isClosed": self.isClosed,
                "roundOpenSlot": self.roundOpenSlot,
                "roundOpenTimestamp": self.roundOpenTimestamp,
                "result": self.result.to_encodable(),
                "stdDeviation": self.stdDeviation.to_encodable(),
                "minResponse": self.minResponse.to_encodable(),
                "maxResponse": self.maxResponse.to_encodable(),
                "oraclePubkeysData": self.oraclePubkeysData,
                "mediansData": self.mediansData,
                "currentPayout": self.currentPayout,
                "mediansFulfilled": self.mediansFulfilled,
                "errorsFulfilled": self.errorsFulfilled,
                }

    def to_json(self) -> AggregatorRoundJSON:
        return {
                "numSuccess": self.numSuccess,
                "numError": self.numError,
                "isClosed": self.isClosed,
                "roundOpenSlot": self.roundOpenSlot,
                "roundOpenTimestamp": self.roundOpenTimestamp,
                "result": self.result.to_json(),
                "stdDeviation": self.stdDeviation.to_json(),
                "minResponse": self.minResponse.to_json(),
                "maxResponse": self.maxResponse.to_json(),
                "oraclePubkeysData": list(map(lambda item:str(item),self.oraclePubkeysData)),
                "mediansData": list(map(lambda item:item.to_json(),self.mediansData)),
                "currentPayout": self.currentPayout,
                "mediansFulfilled": self.mediansFulfilled,
                "errorsFulfilled": self.errorsFulfilled,
                }

    @classmethod
    def from_json(cls, obj: AggregatorRoundJSON) -> "AggregatorRound":
        return cls(
                numSuccess=obj["numSuccess"],
                numError=obj["numError"],
                isClosed=obj["isClosed"],
                roundOpenSlot=obj["roundOpenSlot"],
                roundOpenTimestamp=obj["roundOpenTimestamp"],
                result=switchboardDecimal.SwitchboardDecimal.from_json(obj["result"]),
                stdDeviation=switchboardDecimal.SwitchboardDecimal.from_json(obj["stdDeviation"]),
                minResponse=switchboardDecimal.SwitchboardDecimal.from_json(obj["minResponse"]),
                maxResponse=switchboardDecimal.SwitchboardDecimal.from_json(obj["maxResponse"]),
                oraclePubkeysData=list(map(lambda item:SolPubkey.from_string(item),obj["oraclePubkeysData"])),
                mediansData=list(map(lambda item:switchboardDecimal.SwitchboardDecimal.from_json(item),obj["mediansData"])),
                currentPayout=obj["currentPayout"],
                mediansFulfilled=obj["mediansFulfilled"],
                errorsFulfilled=obj["errorsFulfilled"],
        )






