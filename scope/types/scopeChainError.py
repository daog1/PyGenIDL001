'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;
from solders.sysvar import RENT;


class PriceChainTooLongJSON(typing.TypedDict):
    kind: typing.Literal["PriceChainTooLong"]


@dataclass
class PriceChainTooLong:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> PriceChainTooLongJSON:
        return PriceChainTooLongJSON(
            kind="PriceChainTooLong",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PriceChainTooLong": {},
        }




class PriceChainConversionFailureJSON(typing.TypedDict):
    kind: typing.Literal["PriceChainConversionFailure"]


@dataclass
class PriceChainConversionFailure:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> PriceChainConversionFailureJSON:
        return PriceChainConversionFailureJSON(
            kind="PriceChainConversionFailure",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PriceChainConversionFailure": {},
        }




class NoChainForTokenJSON(typing.TypedDict):
    kind: typing.Literal["NoChainForToken"]


@dataclass
class NoChainForToken:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> NoChainForTokenJSON:
        return NoChainForTokenJSON(
            kind="NoChainForToken",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "NoChainForToken": {},
        }




class InvalidPricesInChainJSON(typing.TypedDict):
    kind: typing.Literal["InvalidPricesInChain"]


@dataclass
class InvalidPricesInChain:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> InvalidPricesInChainJSON:
        return InvalidPricesInChainJSON(
            kind="InvalidPricesInChain",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "InvalidPricesInChain": {},
        }




class MathOverflowJSON(typing.TypedDict):
    kind: typing.Literal["MathOverflow"]


@dataclass
class MathOverflow:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> MathOverflowJSON:
        return MathOverflowJSON(
            kind="MathOverflow",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "MathOverflow": {},
        }




class IntegerConversionOverflowJSON(typing.TypedDict):
    kind: typing.Literal["IntegerConversionOverflow"]


@dataclass
class IntegerConversionOverflow:
    discriminator: typing.ClassVar = 5
    def to_json(self) -> IntegerConversionOverflowJSON:
        return IntegerConversionOverflowJSON(
            kind="IntegerConversionOverflow",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "IntegerConversionOverflow": {},
        }





ScopeChainErrorKind = typing.Union[
    PriceChainTooLong,
    PriceChainConversionFailure,
    NoChainForToken,
    InvalidPricesInChain,
    MathOverflow,
    IntegerConversionOverflow,
]
ScopeChainErrorJSON = typing.Union[
    PriceChainTooLongJSON,
    PriceChainConversionFailureJSON,
    NoChainForTokenJSON,
    InvalidPricesInChainJSON,
    MathOverflowJSON,
    IntegerConversionOverflowJSON,
]

def from_decoded(obj: dict) -> ScopeChainErrorKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "PriceChainTooLong" in obj:
      return PriceChainTooLong()
    if "PriceChainConversionFailure" in obj:
      return PriceChainConversionFailure()
    if "NoChainForToken" in obj:
      return NoChainForToken()
    if "InvalidPricesInChain" in obj:
      return InvalidPricesInChain()
    if "MathOverflow" in obj:
      return MathOverflow()
    if "IntegerConversionOverflow" in obj:
      return IntegerConversionOverflow()
    raise ValueError("Invalid enum object")

def from_json(obj: ScopeChainErrorJSON) -> ScopeChainErrorKind:
    if obj["kind"] == "PriceChainTooLong":
        return PriceChainTooLong()

    if obj["kind"] == "PriceChainConversionFailure":
        return PriceChainConversionFailure()

    if obj["kind"] == "NoChainForToken":
        return NoChainForToken()

    if obj["kind"] == "InvalidPricesInChain":
        return InvalidPricesInChain()

    if obj["kind"] == "MathOverflow":
        return MathOverflow()

    if obj["kind"] == "IntegerConversionOverflow":
        return IntegerConversionOverflow()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"PriceChainTooLong" / borsh.CStruct(),
"PriceChainConversionFailure" / borsh.CStruct(),
"NoChainForToken" / borsh.CStruct(),
"InvalidPricesInChain" / borsh.CStruct(),
"MathOverflow" / borsh.CStruct(),
"IntegerConversionOverflow" / borsh.CStruct(),
)
