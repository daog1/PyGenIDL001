'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey;
from anchorpy.coder.accounts import ACCOUNT_DISCRIMINATOR_SIZE;
from anchorpy.error import AccountInvalidDiscriminator;
from anchorpy.utils.rpc import get_multiple_accounts;
from dataclasses import dataclass;
from solana.rpc.async_api import AsyncClient;
from solana.rpc.commitment import Commitment;
from solana.rpc.types import MemcmpOpts;
from solders.pubkey import Pubkey;
from .. import types;
from ..program_id import PROGRAM_ID;


class AmmJSON(typing.TypedDict):
    initializerKey: str
    initializerDepositTokenAccount: str
    initializerReceiveTokenAccount: str
    initializerAmount: int
    takerAmount: int
    isInitialized: bool
    bumpSeed: int
    freezeTrade: int
    freezeDeposit: int
    freezeWithdraw: int
    baseDecimals: int
    tokenProgramId: str
    tokenAAccount: str
    tokenBAccount: str
    poolMint: str
    tokenAMint: str
    tokenBMint: str
    feeAccount: str
    oracleMainAccount: str
    oracleSubAccount: str
    oraclePcAccount: str
    fees: types.ammFees.AmmFeesJSON
    curve: types.ammCurve.AmmCurveJSON
    config: types.ammConfig.AmmConfigJSON
    ammPTemp1: str
    ammPTemp2: str
    ammPTemp3: str
    ammPTemp4: str
    ammPTemp5: str

@dataclass
class Amm:
    discriminator: typing.ClassVar = b"\x8f\xf5\xc8\x11\x4a\xd6\xc4\x87";

    layout: typing.ClassVar = borsh.CStruct(
        "initializerKey" /BorshPubkey,
        "initializerDepositTokenAccount" /BorshPubkey,
        "initializerReceiveTokenAccount" /BorshPubkey,
        "initializerAmount" /borsh.U64,
        "takerAmount" /borsh.U64,
        "isInitialized" /borsh.U8,
        "bumpSeed" /borsh.U8,
        "freezeTrade" /borsh.U8,
        "freezeDeposit" /borsh.U8,
        "freezeWithdraw" /borsh.U8,
        "baseDecimals" /borsh.U8,
        "tokenProgramId" /BorshPubkey,
        "tokenAAccount" /BorshPubkey,
        "tokenBAccount" /BorshPubkey,
        "poolMint" /BorshPubkey,
        "tokenAMint" /BorshPubkey,
        "tokenBMint" /BorshPubkey,
        "feeAccount" /BorshPubkey,
        "oracleMainAccount" /BorshPubkey,
        "oracleSubAccount" /BorshPubkey,
        "oraclePcAccount" /BorshPubkey,
        "fees" /types.ammFees.AmmFees.layout,
        "curve" /types.ammCurve.AmmCurve.layout,
        "config" /types.ammConfig.AmmConfig.layout,
        "ammPTemp1" /BorshPubkey,
        "ammPTemp2" /BorshPubkey,
        "ammPTemp3" /BorshPubkey,
        "ammPTemp4" /BorshPubkey,
        "ammPTemp5" /BorshPubkey,
        )
    #fields
    initializerKey: Pubkey
    initializerDepositTokenAccount: Pubkey
    initializerReceiveTokenAccount: Pubkey
    initializerAmount: int
    takerAmount: int
    isInitialized: bool
    bumpSeed: int
    freezeTrade: int
    freezeDeposit: int
    freezeWithdraw: int
    baseDecimals: int
    tokenProgramId: Pubkey
    tokenAAccount: Pubkey
    tokenBAccount: Pubkey
    poolMint: Pubkey
    tokenAMint: Pubkey
    tokenBMint: Pubkey
    feeAccount: Pubkey
    oracleMainAccount: Pubkey
    oracleSubAccount: Pubkey
    oraclePcAccount: Pubkey
    fees: types.ammFees.AmmFees
    curve: types.ammCurve.AmmCurve
    config: types.ammConfig.AmmConfig
    ammPTemp1: Pubkey
    ammPTemp2: Pubkey
    ammPTemp3: Pubkey
    ammPTemp4: Pubkey
    ammPTemp5: Pubkey
    

    @classmethod
    async def fetch(
        cls,
        conn: AsyncClient,
        address: Pubkey,
        commitment: typing.Optional[Commitment] = None,
        program_id: Pubkey = PROGRAM_ID,
    ) -> typing.Optional["Amm"]:
        resp = await conn.get_account_info(address, commitment=commitment)
        info = resp.value
        if info is None:
            return None
        if info.owner != program_id:
            raise ValueError("Account does not belong to this program")
        bytes_data = info.data
        return cls.decode(bytes_data)

    @classmethod
    async def fetch_multiple(
        cls,
        conn: AsyncClient,
        addresses: list[Pubkey],
        commitment: typing.Optional[Commitment] = None,
        program_id: Pubkey = PROGRAM_ID,
    ) -> typing.List[typing.Optional["Amm"]]:
        infos = await get_multiple_accounts(conn, addresses, commitment=commitment)
        res: typing.List[typing.Optional["Amm"]] = []
        for info in infos:
            if info is None:
                res.append(None)
                continue
            if info.account.owner != program_id:
                raise ValueError("Account does not belong to this program")
            res.append(cls.decode(info.account.data))
        return res

    @classmethod
    def decode(cls, data: bytes) -> "Amm":
        if data[:ACCOUNT_DISCRIMINATOR_SIZE] != cls.discriminator:
            raise AccountInvalidDiscriminator(
                "The discriminator for this account is invalid"
            )
        dec = Amm.layout.parse(data[ACCOUNT_DISCRIMINATOR_SIZE:])
        return cls(
                initializerKey=dec.initializerKey,
                initializerDepositTokenAccount=dec.initializerDepositTokenAccount,
                initializerReceiveTokenAccount=dec.initializerReceiveTokenAccount,
                initializerAmount=dec.initializerAmount,
                takerAmount=dec.takerAmount,
                isInitialized=dec.isInitialized,
                bumpSeed=dec.bumpSeed,
                freezeTrade=dec.freezeTrade,
                freezeDeposit=dec.freezeDeposit,
                freezeWithdraw=dec.freezeWithdraw,
                baseDecimals=dec.baseDecimals,
                tokenProgramId=dec.tokenProgramId,
                tokenAAccount=dec.tokenAAccount,
                tokenBAccount=dec.tokenBAccount,
                poolMint=dec.poolMint,
                tokenAMint=dec.tokenAMint,
                tokenBMint=dec.tokenBMint,
                feeAccount=dec.feeAccount,
                oracleMainAccount=dec.oracleMainAccount,
                oracleSubAccount=dec.oracleSubAccount,
                oraclePcAccount=dec.oraclePcAccount,
                fees=types.ammFees.AmmFees.from_decoded(dec.fees),
                curve=types.ammCurve.AmmCurve.from_decoded(dec.curve),
                config=types.ammConfig.AmmConfig.from_decoded(dec.config),
                ammPTemp1=dec.ammPTemp1,
                ammPTemp2=dec.ammPTemp2,
                ammPTemp3=dec.ammPTemp3,
                ammPTemp4=dec.ammPTemp4,
                ammPTemp5=dec.ammPTemp5,
                )

    def to_json(self) -> AmmJSON:
        return {
                "initializerKey": str(self.initializerKey),
                "initializerDepositTokenAccount": str(self.initializerDepositTokenAccount),
                "initializerReceiveTokenAccount": str(self.initializerReceiveTokenAccount),
                "initializerAmount": self.initializerAmount,
                "takerAmount": self.takerAmount,
                "isInitialized": self.isInitialized,
                "bumpSeed": self.bumpSeed,
                "freezeTrade": self.freezeTrade,
                "freezeDeposit": self.freezeDeposit,
                "freezeWithdraw": self.freezeWithdraw,
                "baseDecimals": self.baseDecimals,
                "tokenProgramId": str(self.tokenProgramId),
                "tokenAAccount": str(self.tokenAAccount),
                "tokenBAccount": str(self.tokenBAccount),
                "poolMint": str(self.poolMint),
                "tokenAMint": str(self.tokenAMint),
                "tokenBMint": str(self.tokenBMint),
                "feeAccount": str(self.feeAccount),
                "oracleMainAccount": str(self.oracleMainAccount),
                "oracleSubAccount": str(self.oracleSubAccount),
                "oraclePcAccount": str(self.oraclePcAccount),
                "fees": self.fees.to_json(),
                "curve": self.curve.to_json(),
                "config": self.config.to_json(),
                "ammPTemp1": str(self.ammPTemp1),
                "ammPTemp2": str(self.ammPTemp2),
                "ammPTemp3": str(self.ammPTemp3),
                "ammPTemp4": str(self.ammPTemp4),
                "ammPTemp5": str(self.ammPTemp5),
                }

    @classmethod
    def from_json(cls, obj: AmmJSON) -> "Amm":
        return cls(
                initializerKey=Pubkey.from_string(obj["initializerKey"]),
                initializerDepositTokenAccount=Pubkey.from_string(obj["initializerDepositTokenAccount"]),
                initializerReceiveTokenAccount=Pubkey.from_string(obj["initializerReceiveTokenAccount"]),
                initializerAmount=obj["initializerAmount"],
                takerAmount=obj["takerAmount"],
                isInitialized=obj["isInitialized"],
                bumpSeed=obj["bumpSeed"],
                freezeTrade=obj["freezeTrade"],
                freezeDeposit=obj["freezeDeposit"],
                freezeWithdraw=obj["freezeWithdraw"],
                baseDecimals=obj["baseDecimals"],
                tokenProgramId=Pubkey.from_string(obj["tokenProgramId"]),
                tokenAAccount=Pubkey.from_string(obj["tokenAAccount"]),
                tokenBAccount=Pubkey.from_string(obj["tokenBAccount"]),
                poolMint=Pubkey.from_string(obj["poolMint"]),
                tokenAMint=Pubkey.from_string(obj["tokenAMint"]),
                tokenBMint=Pubkey.from_string(obj["tokenBMint"]),
                feeAccount=Pubkey.from_string(obj["feeAccount"]),
                oracleMainAccount=Pubkey.from_string(obj["oracleMainAccount"]),
                oracleSubAccount=Pubkey.from_string(obj["oracleSubAccount"]),
                oraclePcAccount=Pubkey.from_string(obj["oraclePcAccount"]),
                fees=types.ammFees.AmmFees.from_json(obj["fees"]),
                curve=types.ammCurve.AmmCurve.from_json(obj["curve"]),
                config=types.ammConfig.AmmConfig.from_json(obj["config"]),
                ammPTemp1=Pubkey.from_string(obj["ammPTemp1"]),
                ammPTemp2=Pubkey.from_string(obj["ammPTemp2"]),
                ammPTemp3=Pubkey.from_string(obj["ammPTemp3"]),
                ammPTemp4=Pubkey.from_string(obj["ammPTemp4"]),
                ammPTemp5=Pubkey.from_string(obj["ammPTemp5"]),
                )




