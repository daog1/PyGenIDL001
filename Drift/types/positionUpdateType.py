'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class OpenJSON(typing.TypedDict):
    kind: typing.Literal["Open"]


@dataclass
class Open:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> OpenJSON:
        return OpenJSON(
            kind="Open",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Open": {},
        }



class IncreaseJSON(typing.TypedDict):
    kind: typing.Literal["Increase"]


@dataclass
class Increase:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> IncreaseJSON:
        return IncreaseJSON(
            kind="Increase",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Increase": {},
        }



class ReduceJSON(typing.TypedDict):
    kind: typing.Literal["Reduce"]


@dataclass
class Reduce:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> ReduceJSON:
        return ReduceJSON(
            kind="Reduce",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Reduce": {},
        }



class CloseJSON(typing.TypedDict):
    kind: typing.Literal["Close"]


@dataclass
class Close:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> CloseJSON:
        return CloseJSON(
            kind="Close",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Close": {},
        }



class FlipJSON(typing.TypedDict):
    kind: typing.Literal["Flip"]


@dataclass
class Flip:
    discriminator: typing.ClassVar = 4
    @classmethod
    def to_json(cls) -> FlipJSON:
        return FlipJSON(
            kind="Flip",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Flip": {},
        }





PositionUpdateTypeKind = typing.Union[
Open,
Increase,
Reduce,
Close,
Flip,
]
PositionUpdateTypeJSON = typing.Union[
OpenJSON,
IncreaseJSON,
ReduceJSON,
CloseJSON,
FlipJSON,
]

def from_decoded(obj: dict) -> PositionUpdateTypeKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Open" in obj:
      return Open()
    if "Increase" in obj:
      return Increase()
    if "Reduce" in obj:
      return Reduce()
    if "Close" in obj:
      return Close()
    if "Flip" in obj:
      return Flip()
    raise ValueError("Invalid enum object")

def from_json(obj: PositionUpdateTypeJSON) -> PositionUpdateTypeKind:
    if obj["kind"] == "Open":
        return Open()
    if obj["kind"] == "Increase":
        return Increase()
    if obj["kind"] == "Reduce":
        return Reduce()
    if obj["kind"] == "Close":
        return Close()
    if obj["kind"] == "Flip":
        return Flip()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Open" / borsh.CStruct(),
"Increase" / borsh.CStruct(),
"Reduce" / borsh.CStruct(),
"Close" / borsh.CStruct(),
"Flip" / borsh.CStruct(),
)
