'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import EnumForCodegen
from dataclasses import dataclass


class OpenJSON(typing.TypedDict):
    kind: typing.Literal["Open"]


@dataclass
class Open:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> OpenJSON:
        return OpenJSON(
            kind="Open",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Open": {},
        }




class IncreaseJSON(typing.TypedDict):
    kind: typing.Literal["Increase"]


@dataclass
class Increase:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> IncreaseJSON:
        return IncreaseJSON(
            kind="Increase",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Increase": {},
        }




class ReduceJSON(typing.TypedDict):
    kind: typing.Literal["Reduce"]


@dataclass
class Reduce:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> ReduceJSON:
        return ReduceJSON(
            kind="Reduce",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Reduce": {},
        }




class CloseJSON(typing.TypedDict):
    kind: typing.Literal["Close"]


@dataclass
class Close:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> CloseJSON:
        return CloseJSON(
            kind="Close",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Close": {},
        }




class FlipJSON(typing.TypedDict):
    kind: typing.Literal["Flip"]


@dataclass
class Flip:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> FlipJSON:
        return FlipJSON(
            kind="Flip",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Flip": {},
        }





PositionUpdateTypeKind = typing.Union[
    Open,
    Increase,
    Reduce,
    Close,
    Flip,
]
PositionUpdateTypeJSON = typing.Union[
    OpenJSON,
    IncreaseJSON,
    ReduceJSON,
    CloseJSON,
    FlipJSON,
]

def from_decoded(obj: dict) -> PositionUpdateTypeKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Open" in obj:
      return Open()
    if "Increase" in obj:
      return Increase()
    if "Reduce" in obj:
      return Reduce()
    if "Close" in obj:
      return Close()
    if "Flip" in obj:
      return Flip()
    raise ValueError("Invalid enum object")

def from_json(obj: PositionUpdateTypeJSON) -> PositionUpdateTypeKind:
    if obj["kind"] == "Open":
        return Open()

    if obj["kind"] == "Increase":
        return Increase()

    if obj["kind"] == "Reduce":
        return Reduce()

    if obj["kind"] == "Close":
        return Close()

    if obj["kind"] == "Flip":
        return Flip()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")


layout = EnumForCodegen(
"Open" / borsh.CStruct(),
"Increase" / borsh.CStruct(),
"Reduce" / borsh.CStruct(),
"Close" / borsh.CStruct(),
"Flip" / borsh.CStruct(),
)
