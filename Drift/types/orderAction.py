'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;
from solders.sysvar import RENT;


class PlaceJSON(typing.TypedDict):
    kind: typing.Literal["Place"]


@dataclass
class Place:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> PlaceJSON:
        return PlaceJSON(
            kind="Place",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Place": {},
        }




class CancelJSON(typing.TypedDict):
    kind: typing.Literal["Cancel"]


@dataclass
class Cancel:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> CancelJSON:
        return CancelJSON(
            kind="Cancel",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Cancel": {},
        }




class FillJSON(typing.TypedDict):
    kind: typing.Literal["Fill"]


@dataclass
class Fill:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> FillJSON:
        return FillJSON(
            kind="Fill",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Fill": {},
        }




class TriggerJSON(typing.TypedDict):
    kind: typing.Literal["Trigger"]


@dataclass
class Trigger:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> TriggerJSON:
        return TriggerJSON(
            kind="Trigger",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Trigger": {},
        }




class ExpireJSON(typing.TypedDict):
    kind: typing.Literal["Expire"]


@dataclass
class Expire:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> ExpireJSON:
        return ExpireJSON(
            kind="Expire",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Expire": {},
        }





OrderActionKind = typing.Union[
    Place,
    Cancel,
    Fill,
    Trigger,
    Expire,
]
OrderActionJSON = typing.Union[
    PlaceJSON,
    CancelJSON,
    FillJSON,
    TriggerJSON,
    ExpireJSON,
]

def from_decoded(obj: dict) -> OrderActionKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Place" in obj:
      return Place()
    if "Cancel" in obj:
      return Cancel()
    if "Fill" in obj:
      return Fill()
    if "Trigger" in obj:
      return Trigger()
    if "Expire" in obj:
      return Expire()
    raise ValueError("Invalid enum object")

def from_json(obj: OrderActionJSON) -> OrderActionKind:
    if obj["kind"] == "Place":
        return Place()

    if obj["kind"] == "Cancel":
        return Cancel()

    if obj["kind"] == "Fill":
        return Fill()

    if obj["kind"] == "Trigger":
        return Trigger()

    if obj["kind"] == "Expire":
        return Expire()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Place" / borsh.CStruct(),
"Cancel" / borsh.CStruct(),
"Fill" / borsh.CStruct(),
"Trigger" / borsh.CStruct(),
"Expire" / borsh.CStruct(),
)
