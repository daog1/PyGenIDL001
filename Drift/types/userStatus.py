'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class BeingLiquidatedJSON(typing.TypedDict):
    kind: typing.Literal["BeingLiquidated"]


@dataclass
class BeingLiquidated:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> BeingLiquidatedJSON:
        return BeingLiquidatedJSON(
            kind="BeingLiquidated",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "BeingLiquidated": {},
        }



class BankruptJSON(typing.TypedDict):
    kind: typing.Literal["Bankrupt"]


@dataclass
class Bankrupt:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> BankruptJSON:
        return BankruptJSON(
            kind="Bankrupt",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Bankrupt": {},
        }



class ReduceOnlyJSON(typing.TypedDict):
    kind: typing.Literal["ReduceOnly"]


@dataclass
class ReduceOnly:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> ReduceOnlyJSON:
        return ReduceOnlyJSON(
            kind="ReduceOnly",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "ReduceOnly": {},
        }



class AdvancedLpJSON(typing.TypedDict):
    kind: typing.Literal["AdvancedLp"]


@dataclass
class AdvancedLp:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> AdvancedLpJSON:
        return AdvancedLpJSON(
            kind="AdvancedLp",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "AdvancedLp": {},
        }



class ProtectedMakerOrdersJSON(typing.TypedDict):
    kind: typing.Literal["ProtectedMakerOrders"]


@dataclass
class ProtectedMakerOrders:
    discriminator: typing.ClassVar = 4
    @classmethod
    def to_json(cls) -> ProtectedMakerOrdersJSON:
        return ProtectedMakerOrdersJSON(
            kind="ProtectedMakerOrders",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "ProtectedMakerOrders": {},
        }





UserStatusKind = typing.Union[
BeingLiquidated,
Bankrupt,
ReduceOnly,
AdvancedLp,
ProtectedMakerOrders,
]
UserStatusJSON = typing.Union[
BeingLiquidatedJSON,
BankruptJSON,
ReduceOnlyJSON,
AdvancedLpJSON,
ProtectedMakerOrdersJSON,
]

def from_decoded(obj: dict) -> UserStatusKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "BeingLiquidated" in obj:
      return BeingLiquidated()
    if "Bankrupt" in obj:
      return Bankrupt()
    if "ReduceOnly" in obj:
      return ReduceOnly()
    if "AdvancedLp" in obj:
      return AdvancedLp()
    if "ProtectedMakerOrders" in obj:
      return ProtectedMakerOrders()
    raise ValueError("Invalid enum object")

def from_json(obj: UserStatusJSON) -> UserStatusKind:
    if obj["kind"] == "BeingLiquidated":
        return BeingLiquidated()
    if obj["kind"] == "Bankrupt":
        return Bankrupt()
    if obj["kind"] == "ReduceOnly":
        return ReduceOnly()
    if obj["kind"] == "AdvancedLp":
        return AdvancedLp()
    if obj["kind"] == "ProtectedMakerOrders":
        return ProtectedMakerOrders()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"BeingLiquidated" / borsh.CStruct(),
"Bankrupt" / borsh.CStruct(),
"ReduceOnly" / borsh.CStruct(),
"AdvancedLp" / borsh.CStruct(),
"ProtectedMakerOrders" / borsh.CStruct(),
)
