'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import EnumForCodegen
from dataclasses import dataclass


class BeingLiquidatedJSON(typing.TypedDict):
    kind: typing.Literal["BeingLiquidated"]


@dataclass
class BeingLiquidated:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> BeingLiquidatedJSON:
        return BeingLiquidatedJSON(
            kind="BeingLiquidated",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "BeingLiquidated": {},
        }




class BankruptJSON(typing.TypedDict):
    kind: typing.Literal["Bankrupt"]


@dataclass
class Bankrupt:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> BankruptJSON:
        return BankruptJSON(
            kind="Bankrupt",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Bankrupt": {},
        }




class ReduceOnlyJSON(typing.TypedDict):
    kind: typing.Literal["ReduceOnly"]


@dataclass
class ReduceOnly:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> ReduceOnlyJSON:
        return ReduceOnlyJSON(
            kind="ReduceOnly",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "ReduceOnly": {},
        }




class AdvancedLpJSON(typing.TypedDict):
    kind: typing.Literal["AdvancedLp"]


@dataclass
class AdvancedLp:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> AdvancedLpJSON:
        return AdvancedLpJSON(
            kind="AdvancedLp",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "AdvancedLp": {},
        }




class ProtectedMakerOrdersJSON(typing.TypedDict):
    kind: typing.Literal["ProtectedMakerOrders"]


@dataclass
class ProtectedMakerOrders:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> ProtectedMakerOrdersJSON:
        return ProtectedMakerOrdersJSON(
            kind="ProtectedMakerOrders",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "ProtectedMakerOrders": {},
        }





UserStatusKind = typing.Union[
    BeingLiquidated,
    Bankrupt,
    ReduceOnly,
    AdvancedLp,
    ProtectedMakerOrders,
]
UserStatusJSON = typing.Union[
    BeingLiquidatedJSON,
    BankruptJSON,
    ReduceOnlyJSON,
    AdvancedLpJSON,
    ProtectedMakerOrdersJSON,
]

def from_decoded(obj: dict) -> UserStatusKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "BeingLiquidated" in obj:
      return BeingLiquidated()
    if "Bankrupt" in obj:
      return Bankrupt()
    if "ReduceOnly" in obj:
      return ReduceOnly()
    if "AdvancedLp" in obj:
      return AdvancedLp()
    if "ProtectedMakerOrders" in obj:
      return ProtectedMakerOrders()
    raise ValueError("Invalid enum object")

def from_json(obj: UserStatusJSON) -> UserStatusKind:
    if obj["kind"] == "BeingLiquidated":
        return BeingLiquidated()

    if obj["kind"] == "Bankrupt":
        return Bankrupt()

    if obj["kind"] == "ReduceOnly":
        return ReduceOnly()

    if obj["kind"] == "AdvancedLp":
        return AdvancedLp()

    if obj["kind"] == "ProtectedMakerOrders":
        return ProtectedMakerOrders()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")


layout = EnumForCodegen(
"BeingLiquidated" / borsh.CStruct(),
"Bankrupt" / borsh.CStruct(),
"ReduceOnly" / borsh.CStruct(),
"AdvancedLp" / borsh.CStruct(),
"ProtectedMakerOrders" / borsh.CStruct(),
)
