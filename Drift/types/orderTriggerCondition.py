'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class AboveJSON(typing.TypedDict):
    kind: typing.Literal["Above"]


@dataclass
class Above:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> AboveJSON:
        return AboveJSON(
            kind="Above",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Above": {},
        }



class BelowJSON(typing.TypedDict):
    kind: typing.Literal["Below"]


@dataclass
class Below:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> BelowJSON:
        return BelowJSON(
            kind="Below",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Below": {},
        }



class TriggeredAboveJSON(typing.TypedDict):
    kind: typing.Literal["TriggeredAbove"]


@dataclass
class TriggeredAbove:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> TriggeredAboveJSON:
        return TriggeredAboveJSON(
            kind="TriggeredAbove",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "TriggeredAbove": {},
        }



class TriggeredBelowJSON(typing.TypedDict):
    kind: typing.Literal["TriggeredBelow"]


@dataclass
class TriggeredBelow:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> TriggeredBelowJSON:
        return TriggeredBelowJSON(
            kind="TriggeredBelow",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "TriggeredBelow": {},
        }





OrderTriggerConditionKind = typing.Union[
Above,
Below,
TriggeredAbove,
TriggeredBelow,
]
OrderTriggerConditionJSON = typing.Union[
AboveJSON,
BelowJSON,
TriggeredAboveJSON,
TriggeredBelowJSON,
]

def from_decoded(obj: dict) -> OrderTriggerConditionKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Above" in obj:
      return Above()
    if "Below" in obj:
      return Below()
    if "TriggeredAbove" in obj:
      return TriggeredAbove()
    if "TriggeredBelow" in obj:
      return TriggeredBelow()
    raise ValueError("Invalid enum object")

def from_json(obj: OrderTriggerConditionJSON) -> OrderTriggerConditionKind:
    if obj["kind"] == "Above":
        return Above()
    if obj["kind"] == "Below":
        return Below()
    if obj["kind"] == "TriggeredAbove":
        return TriggeredAbove()
    if obj["kind"] == "TriggeredBelow":
        return TriggeredBelow()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Above" / borsh.CStruct(),
"Below" / borsh.CStruct(),
"TriggeredAbove" / borsh.CStruct(),
"TriggeredBelow" / borsh.CStruct(),
)
