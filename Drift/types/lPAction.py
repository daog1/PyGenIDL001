'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import EnumForCodegen
from dataclasses import dataclass


class AddLiquidityJSON(typing.TypedDict):
    kind: typing.Literal["AddLiquidity"]


@dataclass
class AddLiquidity:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> AddLiquidityJSON:
        return AddLiquidityJSON(
            kind="AddLiquidity",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "AddLiquidity": {},
        }




class RemoveLiquidityJSON(typing.TypedDict):
    kind: typing.Literal["RemoveLiquidity"]


@dataclass
class RemoveLiquidity:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> RemoveLiquidityJSON:
        return RemoveLiquidityJSON(
            kind="RemoveLiquidity",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "RemoveLiquidity": {},
        }




class SettleLiquidityJSON(typing.TypedDict):
    kind: typing.Literal["SettleLiquidity"]


@dataclass
class SettleLiquidity:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> SettleLiquidityJSON:
        return SettleLiquidityJSON(
            kind="SettleLiquidity",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "SettleLiquidity": {},
        }




class RemoveLiquidityDeriskJSON(typing.TypedDict):
    kind: typing.Literal["RemoveLiquidityDerisk"]


@dataclass
class RemoveLiquidityDerisk:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> RemoveLiquidityDeriskJSON:
        return RemoveLiquidityDeriskJSON(
            kind="RemoveLiquidityDerisk",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "RemoveLiquidityDerisk": {},
        }





LPActionKind = typing.Union[
    AddLiquidity,
    RemoveLiquidity,
    SettleLiquidity,
    RemoveLiquidityDerisk,
]
LPActionJSON = typing.Union[
    AddLiquidityJSON,
    RemoveLiquidityJSON,
    SettleLiquidityJSON,
    RemoveLiquidityDeriskJSON,
]

def from_decoded(obj: dict) -> LPActionKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "AddLiquidity" in obj:
      return AddLiquidity()
    if "RemoveLiquidity" in obj:
      return RemoveLiquidity()
    if "SettleLiquidity" in obj:
      return SettleLiquidity()
    if "RemoveLiquidityDerisk" in obj:
      return RemoveLiquidityDerisk()
    raise ValueError("Invalid enum object")

def from_json(obj: LPActionJSON) -> LPActionKind:
    if obj["kind"] == "AddLiquidity":
        return AddLiquidity()

    if obj["kind"] == "RemoveLiquidity":
        return RemoveLiquidity()

    if obj["kind"] == "SettleLiquidity":
        return SettleLiquidity()

    if obj["kind"] == "RemoveLiquidityDerisk":
        return RemoveLiquidityDerisk()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")


layout = EnumForCodegen(
"AddLiquidity" / borsh.CStruct(),
"RemoveLiquidity" / borsh.CStruct(),
"SettleLiquidity" / borsh.CStruct(),
"RemoveLiquidityDerisk" / borsh.CStruct(),
)
