'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class AddLiquidityJSON(typing.TypedDict):
    kind: typing.Literal["AddLiquidity"]


@dataclass
class AddLiquidity:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> AddLiquidityJSON:
        return AddLiquidityJSON(
            kind="AddLiquidity",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "AddLiquidity": {},
        }



class RemoveLiquidityJSON(typing.TypedDict):
    kind: typing.Literal["RemoveLiquidity"]


@dataclass
class RemoveLiquidity:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> RemoveLiquidityJSON:
        return RemoveLiquidityJSON(
            kind="RemoveLiquidity",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "RemoveLiquidity": {},
        }



class SettleLiquidityJSON(typing.TypedDict):
    kind: typing.Literal["SettleLiquidity"]


@dataclass
class SettleLiquidity:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> SettleLiquidityJSON:
        return SettleLiquidityJSON(
            kind="SettleLiquidity",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "SettleLiquidity": {},
        }



class RemoveLiquidityDeriskJSON(typing.TypedDict):
    kind: typing.Literal["RemoveLiquidityDerisk"]


@dataclass
class RemoveLiquidityDerisk:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> RemoveLiquidityDeriskJSON:
        return RemoveLiquidityDeriskJSON(
            kind="RemoveLiquidityDerisk",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "RemoveLiquidityDerisk": {},
        }





LPActionKind = typing.Union[
AddLiquidity,
RemoveLiquidity,
SettleLiquidity,
RemoveLiquidityDerisk,
]
LPActionJSON = typing.Union[
AddLiquidityJSON,
RemoveLiquidityJSON,
SettleLiquidityJSON,
RemoveLiquidityDeriskJSON,
]

def from_decoded(obj: dict) -> LPActionKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "AddLiquidity" in obj:
      return AddLiquidity()
    if "RemoveLiquidity" in obj:
      return RemoveLiquidity()
    if "SettleLiquidity" in obj:
      return SettleLiquidity()
    if "RemoveLiquidityDerisk" in obj:
      return RemoveLiquidityDerisk()
    raise ValueError("Invalid enum object")

def from_json(obj: LPActionJSON) -> LPActionKind:
    if obj["kind"] == "AddLiquidity":
        return AddLiquidity()
    if obj["kind"] == "RemoveLiquidity":
        return RemoveLiquidity()
    if obj["kind"] == "SettleLiquidity":
        return SettleLiquidity()
    if obj["kind"] == "RemoveLiquidityDerisk":
        return RemoveLiquidityDerisk()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"AddLiquidity" / borsh.CStruct(),
"RemoveLiquidity" / borsh.CStruct(),
"SettleLiquidity" / borsh.CStruct(),
"RemoveLiquidityDerisk" / borsh.CStruct(),
)
