'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;
from solders.sysvar import RENT;


class NoneJSON(typing.TypedDict):
    kind: typing.Literal["None"]


@dataclass
class None_:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> NoneJSON:
        return NoneJSON(
            kind="None",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "None": {},
        }




class InsufficientFreeCollateralJSON(typing.TypedDict):
    kind: typing.Literal["InsufficientFreeCollateral"]


@dataclass
class InsufficientFreeCollateral:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> InsufficientFreeCollateralJSON:
        return InsufficientFreeCollateralJSON(
            kind="InsufficientFreeCollateral",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "InsufficientFreeCollateral": {},
        }




class OraclePriceBreachedLimitPriceJSON(typing.TypedDict):
    kind: typing.Literal["OraclePriceBreachedLimitPrice"]


@dataclass
class OraclePriceBreachedLimitPrice:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> OraclePriceBreachedLimitPriceJSON:
        return OraclePriceBreachedLimitPriceJSON(
            kind="OraclePriceBreachedLimitPrice",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OraclePriceBreachedLimitPrice": {},
        }




class MarketOrderFilledToLimitPriceJSON(typing.TypedDict):
    kind: typing.Literal["MarketOrderFilledToLimitPrice"]


@dataclass
class MarketOrderFilledToLimitPrice:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> MarketOrderFilledToLimitPriceJSON:
        return MarketOrderFilledToLimitPriceJSON(
            kind="MarketOrderFilledToLimitPrice",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "MarketOrderFilledToLimitPrice": {},
        }




class OrderExpiredJSON(typing.TypedDict):
    kind: typing.Literal["OrderExpired"]


@dataclass
class OrderExpired:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> OrderExpiredJSON:
        return OrderExpiredJSON(
            kind="OrderExpired",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderExpired": {},
        }




class LiquidationJSON(typing.TypedDict):
    kind: typing.Literal["Liquidation"]


@dataclass
class Liquidation:
    discriminator: typing.ClassVar = 5
    def to_json(self) -> LiquidationJSON:
        return LiquidationJSON(
            kind="Liquidation",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Liquidation": {},
        }




class OrderFilledWithAMMJSON(typing.TypedDict):
    kind: typing.Literal["OrderFilledWithAMM"]


@dataclass
class OrderFilledWithAMM:
    discriminator: typing.ClassVar = 6
    def to_json(self) -> OrderFilledWithAMMJSON:
        return OrderFilledWithAMMJSON(
            kind="OrderFilledWithAMM",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFilledWithAMM": {},
        }




class OrderFilledWithAMMJitJSON(typing.TypedDict):
    kind: typing.Literal["OrderFilledWithAMMJit"]


@dataclass
class OrderFilledWithAMMJit:
    discriminator: typing.ClassVar = 7
    def to_json(self) -> OrderFilledWithAMMJitJSON:
        return OrderFilledWithAMMJitJSON(
            kind="OrderFilledWithAMMJit",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFilledWithAMMJit": {},
        }




class OrderFilledWithMatchJSON(typing.TypedDict):
    kind: typing.Literal["OrderFilledWithMatch"]


@dataclass
class OrderFilledWithMatch:
    discriminator: typing.ClassVar = 8
    def to_json(self) -> OrderFilledWithMatchJSON:
        return OrderFilledWithMatchJSON(
            kind="OrderFilledWithMatch",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFilledWithMatch": {},
        }




class OrderFilledWithMatchJitJSON(typing.TypedDict):
    kind: typing.Literal["OrderFilledWithMatchJit"]


@dataclass
class OrderFilledWithMatchJit:
    discriminator: typing.ClassVar = 9
    def to_json(self) -> OrderFilledWithMatchJitJSON:
        return OrderFilledWithMatchJitJSON(
            kind="OrderFilledWithMatchJit",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFilledWithMatchJit": {},
        }




class MarketExpiredJSON(typing.TypedDict):
    kind: typing.Literal["MarketExpired"]


@dataclass
class MarketExpired:
    discriminator: typing.ClassVar = 10
    def to_json(self) -> MarketExpiredJSON:
        return MarketExpiredJSON(
            kind="MarketExpired",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "MarketExpired": {},
        }




class RiskingIncreasingOrderJSON(typing.TypedDict):
    kind: typing.Literal["RiskingIncreasingOrder"]


@dataclass
class RiskingIncreasingOrder:
    discriminator: typing.ClassVar = 11
    def to_json(self) -> RiskingIncreasingOrderJSON:
        return RiskingIncreasingOrderJSON(
            kind="RiskingIncreasingOrder",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "RiskingIncreasingOrder": {},
        }




class ReduceOnlyOrderIncreasedPositionJSON(typing.TypedDict):
    kind: typing.Literal["ReduceOnlyOrderIncreasedPosition"]


@dataclass
class ReduceOnlyOrderIncreasedPosition:
    discriminator: typing.ClassVar = 12
    def to_json(self) -> ReduceOnlyOrderIncreasedPositionJSON:
        return ReduceOnlyOrderIncreasedPositionJSON(
            kind="ReduceOnlyOrderIncreasedPosition",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "ReduceOnlyOrderIncreasedPosition": {},
        }




class OrderFillWithSerumJSON(typing.TypedDict):
    kind: typing.Literal["OrderFillWithSerum"]


@dataclass
class OrderFillWithSerum:
    discriminator: typing.ClassVar = 13
    def to_json(self) -> OrderFillWithSerumJSON:
        return OrderFillWithSerumJSON(
            kind="OrderFillWithSerum",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFillWithSerum": {},
        }




class NoBorrowLiquidityJSON(typing.TypedDict):
    kind: typing.Literal["NoBorrowLiquidity"]


@dataclass
class NoBorrowLiquidity:
    discriminator: typing.ClassVar = 14
    def to_json(self) -> NoBorrowLiquidityJSON:
        return NoBorrowLiquidityJSON(
            kind="NoBorrowLiquidity",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "NoBorrowLiquidity": {},
        }




class OrderFillWithPhoenixJSON(typing.TypedDict):
    kind: typing.Literal["OrderFillWithPhoenix"]


@dataclass
class OrderFillWithPhoenix:
    discriminator: typing.ClassVar = 15
    def to_json(self) -> OrderFillWithPhoenixJSON:
        return OrderFillWithPhoenixJSON(
            kind="OrderFillWithPhoenix",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFillWithPhoenix": {},
        }




class OrderFilledWithAMMJitLPSplitJSON(typing.TypedDict):
    kind: typing.Literal["OrderFilledWithAMMJitLPSplit"]


@dataclass
class OrderFilledWithAMMJitLPSplit:
    discriminator: typing.ClassVar = 16
    def to_json(self) -> OrderFilledWithAMMJitLPSplitJSON:
        return OrderFilledWithAMMJitLPSplitJSON(
            kind="OrderFilledWithAMMJitLPSplit",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFilledWithAMMJitLPSplit": {},
        }




class OrderFilledWithLPJitJSON(typing.TypedDict):
    kind: typing.Literal["OrderFilledWithLPJit"]


@dataclass
class OrderFilledWithLPJit:
    discriminator: typing.ClassVar = 17
    def to_json(self) -> OrderFilledWithLPJitJSON:
        return OrderFilledWithLPJitJSON(
            kind="OrderFilledWithLPJit",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFilledWithLPJit": {},
        }




class DeriskLpJSON(typing.TypedDict):
    kind: typing.Literal["DeriskLp"]


@dataclass
class DeriskLp:
    discriminator: typing.ClassVar = 18
    def to_json(self) -> DeriskLpJSON:
        return DeriskLpJSON(
            kind="DeriskLp",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "DeriskLp": {},
        }




class OrderFilledWithOpenbookV2JSON(typing.TypedDict):
    kind: typing.Literal["OrderFilledWithOpenbookV2"]


@dataclass
class OrderFilledWithOpenbookV2:
    discriminator: typing.ClassVar = 19
    def to_json(self) -> OrderFilledWithOpenbookV2JSON:
        return OrderFilledWithOpenbookV2JSON(
            kind="OrderFilledWithOpenbookV2",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OrderFilledWithOpenbookV2": {},
        }





OrderActionExplanationKind = typing.Union[
    None_,
    InsufficientFreeCollateral,
    OraclePriceBreachedLimitPrice,
    MarketOrderFilledToLimitPrice,
    OrderExpired,
    Liquidation,
    OrderFilledWithAMM,
    OrderFilledWithAMMJit,
    OrderFilledWithMatch,
    OrderFilledWithMatchJit,
    MarketExpired,
    RiskingIncreasingOrder,
    ReduceOnlyOrderIncreasedPosition,
    OrderFillWithSerum,
    NoBorrowLiquidity,
    OrderFillWithPhoenix,
    OrderFilledWithAMMJitLPSplit,
    OrderFilledWithLPJit,
    DeriskLp,
    OrderFilledWithOpenbookV2,
]
OrderActionExplanationJSON = typing.Union[
    NoneJSON,
    InsufficientFreeCollateralJSON,
    OraclePriceBreachedLimitPriceJSON,
    MarketOrderFilledToLimitPriceJSON,
    OrderExpiredJSON,
    LiquidationJSON,
    OrderFilledWithAMMJSON,
    OrderFilledWithAMMJitJSON,
    OrderFilledWithMatchJSON,
    OrderFilledWithMatchJitJSON,
    MarketExpiredJSON,
    RiskingIncreasingOrderJSON,
    ReduceOnlyOrderIncreasedPositionJSON,
    OrderFillWithSerumJSON,
    NoBorrowLiquidityJSON,
    OrderFillWithPhoenixJSON,
    OrderFilledWithAMMJitLPSplitJSON,
    OrderFilledWithLPJitJSON,
    DeriskLpJSON,
    OrderFilledWithOpenbookV2JSON,
]

def from_decoded(obj: dict) -> OrderActionExplanationKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "None" in obj:
      return None_()
    if "InsufficientFreeCollateral" in obj:
      return InsufficientFreeCollateral()
    if "OraclePriceBreachedLimitPrice" in obj:
      return OraclePriceBreachedLimitPrice()
    if "MarketOrderFilledToLimitPrice" in obj:
      return MarketOrderFilledToLimitPrice()
    if "OrderExpired" in obj:
      return OrderExpired()
    if "Liquidation" in obj:
      return Liquidation()
    if "OrderFilledWithAMM" in obj:
      return OrderFilledWithAMM()
    if "OrderFilledWithAMMJit" in obj:
      return OrderFilledWithAMMJit()
    if "OrderFilledWithMatch" in obj:
      return OrderFilledWithMatch()
    if "OrderFilledWithMatchJit" in obj:
      return OrderFilledWithMatchJit()
    if "MarketExpired" in obj:
      return MarketExpired()
    if "RiskingIncreasingOrder" in obj:
      return RiskingIncreasingOrder()
    if "ReduceOnlyOrderIncreasedPosition" in obj:
      return ReduceOnlyOrderIncreasedPosition()
    if "OrderFillWithSerum" in obj:
      return OrderFillWithSerum()
    if "NoBorrowLiquidity" in obj:
      return NoBorrowLiquidity()
    if "OrderFillWithPhoenix" in obj:
      return OrderFillWithPhoenix()
    if "OrderFilledWithAMMJitLPSplit" in obj:
      return OrderFilledWithAMMJitLPSplit()
    if "OrderFilledWithLPJit" in obj:
      return OrderFilledWithLPJit()
    if "DeriskLp" in obj:
      return DeriskLp()
    if "OrderFilledWithOpenbookV2" in obj:
      return OrderFilledWithOpenbookV2()
    raise ValueError("Invalid enum object")

def from_json(obj: OrderActionExplanationJSON) -> OrderActionExplanationKind:
    if obj["kind"] == "None":
        return None_()

    if obj["kind"] == "InsufficientFreeCollateral":
        return InsufficientFreeCollateral()

    if obj["kind"] == "OraclePriceBreachedLimitPrice":
        return OraclePriceBreachedLimitPrice()

    if obj["kind"] == "MarketOrderFilledToLimitPrice":
        return MarketOrderFilledToLimitPrice()

    if obj["kind"] == "OrderExpired":
        return OrderExpired()

    if obj["kind"] == "Liquidation":
        return Liquidation()

    if obj["kind"] == "OrderFilledWithAMM":
        return OrderFilledWithAMM()

    if obj["kind"] == "OrderFilledWithAMMJit":
        return OrderFilledWithAMMJit()

    if obj["kind"] == "OrderFilledWithMatch":
        return OrderFilledWithMatch()

    if obj["kind"] == "OrderFilledWithMatchJit":
        return OrderFilledWithMatchJit()

    if obj["kind"] == "MarketExpired":
        return MarketExpired()

    if obj["kind"] == "RiskingIncreasingOrder":
        return RiskingIncreasingOrder()

    if obj["kind"] == "ReduceOnlyOrderIncreasedPosition":
        return ReduceOnlyOrderIncreasedPosition()

    if obj["kind"] == "OrderFillWithSerum":
        return OrderFillWithSerum()

    if obj["kind"] == "NoBorrowLiquidity":
        return NoBorrowLiquidity()

    if obj["kind"] == "OrderFillWithPhoenix":
        return OrderFillWithPhoenix()

    if obj["kind"] == "OrderFilledWithAMMJitLPSplit":
        return OrderFilledWithAMMJitLPSplit()

    if obj["kind"] == "OrderFilledWithLPJit":
        return OrderFilledWithLPJit()

    if obj["kind"] == "DeriskLp":
        return DeriskLp()

    if obj["kind"] == "OrderFilledWithOpenbookV2":
        return OrderFilledWithOpenbookV2()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"None" / borsh.CStruct(),
"InsufficientFreeCollateral" / borsh.CStruct(),
"OraclePriceBreachedLimitPrice" / borsh.CStruct(),
"MarketOrderFilledToLimitPrice" / borsh.CStruct(),
"OrderExpired" / borsh.CStruct(),
"Liquidation" / borsh.CStruct(),
"OrderFilledWithAMM" / borsh.CStruct(),
"OrderFilledWithAMMJit" / borsh.CStruct(),
"OrderFilledWithMatch" / borsh.CStruct(),
"OrderFilledWithMatchJit" / borsh.CStruct(),
"MarketExpired" / borsh.CStruct(),
"RiskingIncreasingOrder" / borsh.CStruct(),
"ReduceOnlyOrderIncreasedPosition" / borsh.CStruct(),
"OrderFillWithSerum" / borsh.CStruct(),
"NoBorrowLiquidity" / borsh.CStruct(),
"OrderFillWithPhoenix" / borsh.CStruct(),
"OrderFilledWithAMMJitLPSplit" / borsh.CStruct(),
"OrderFilledWithLPJit" / borsh.CStruct(),
"DeriskLp" / borsh.CStruct(),
"OrderFilledWithOpenbookV2" / borsh.CStruct(),
)
