'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class NonPositiveJSON(typing.TypedDict):
    kind: typing.Literal["NonPositive"]


@dataclass
class NonPositive:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> NonPositiveJSON:
        return NonPositiveJSON(
            kind="NonPositive",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "NonPositive": {},
        }



class TooVolatileJSON(typing.TypedDict):
    kind: typing.Literal["TooVolatile"]


@dataclass
class TooVolatile:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> TooVolatileJSON:
        return TooVolatileJSON(
            kind="TooVolatile",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "TooVolatile": {},
        }



class TooUncertainJSON(typing.TypedDict):
    kind: typing.Literal["TooUncertain"]


@dataclass
class TooUncertain:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> TooUncertainJSON:
        return TooUncertainJSON(
            kind="TooUncertain",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "TooUncertain": {},
        }



class StaleForMarginJSON(typing.TypedDict):
    kind: typing.Literal["StaleForMargin"]


@dataclass
class StaleForMargin:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> StaleForMarginJSON:
        return StaleForMarginJSON(
            kind="StaleForMargin",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "StaleForMargin": {},
        }



class InsufficientDataPointsJSON(typing.TypedDict):
    kind: typing.Literal["InsufficientDataPoints"]


@dataclass
class InsufficientDataPoints:
    discriminator: typing.ClassVar = 4
    @classmethod
    def to_json(cls) -> InsufficientDataPointsJSON:
        return InsufficientDataPointsJSON(
            kind="InsufficientDataPoints",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "InsufficientDataPoints": {},
        }



class StaleForAMMJSON(typing.TypedDict):
    kind: typing.Literal["StaleForAMM"]


@dataclass
class StaleForAMM:
    discriminator: typing.ClassVar = 5
    @classmethod
    def to_json(cls) -> StaleForAMMJSON:
        return StaleForAMMJSON(
            kind="StaleForAMM",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "StaleForAMM": {},
        }



class ValidJSON(typing.TypedDict):
    kind: typing.Literal["Valid"]


@dataclass
class Valid:
    discriminator: typing.ClassVar = 6
    @classmethod
    def to_json(cls) -> ValidJSON:
        return ValidJSON(
            kind="Valid",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Valid": {},
        }





OracleValidityKind = typing.Union[
NonPositive,
TooVolatile,
TooUncertain,
StaleForMargin,
InsufficientDataPoints,
StaleForAMM,
Valid,
]
OracleValidityJSON = typing.Union[
NonPositiveJSON,
TooVolatileJSON,
TooUncertainJSON,
StaleForMarginJSON,
InsufficientDataPointsJSON,
StaleForAMMJSON,
ValidJSON,
]

def from_decoded(obj: dict) -> OracleValidityKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "NonPositive" in obj:
      return NonPositive()
    if "TooVolatile" in obj:
      return TooVolatile()
    if "TooUncertain" in obj:
      return TooUncertain()
    if "StaleForMargin" in obj:
      return StaleForMargin()
    if "InsufficientDataPoints" in obj:
      return InsufficientDataPoints()
    if "StaleForAMM" in obj:
      return StaleForAMM()
    if "Valid" in obj:
      return Valid()
    raise ValueError("Invalid enum object")

def from_json(obj: OracleValidityJSON) -> OracleValidityKind:
    if obj["kind"] == "NonPositive":
        return NonPositive()
    if obj["kind"] == "TooVolatile":
        return TooVolatile()
    if obj["kind"] == "TooUncertain":
        return TooUncertain()
    if obj["kind"] == "StaleForMargin":
        return StaleForMargin()
    if obj["kind"] == "InsufficientDataPoints":
        return InsufficientDataPoints()
    if obj["kind"] == "StaleForAMM":
        return StaleForAMM()
    if obj["kind"] == "Valid":
        return Valid()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"NonPositive" / borsh.CStruct(),
"TooVolatile" / borsh.CStruct(),
"TooUncertain" / borsh.CStruct(),
"StaleForMargin" / borsh.CStruct(),
"InsufficientDataPoints" / borsh.CStruct(),
"StaleForAMM" / borsh.CStruct(),
"Valid" / borsh.CStruct(),
)
