'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;


class NonPositiveJSON(typing.TypedDict):
    kind: typing.Literal["NonPositive"]


@dataclass
class NonPositive:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> NonPositiveJSON:
        return NonPositiveJSON(
            kind="NonPositive",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "NonPositive": {},
        }




class TooVolatileJSON(typing.TypedDict):
    kind: typing.Literal["TooVolatile"]


@dataclass
class TooVolatile:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> TooVolatileJSON:
        return TooVolatileJSON(
            kind="TooVolatile",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "TooVolatile": {},
        }




class TooUncertainJSON(typing.TypedDict):
    kind: typing.Literal["TooUncertain"]


@dataclass
class TooUncertain:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> TooUncertainJSON:
        return TooUncertainJSON(
            kind="TooUncertain",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "TooUncertain": {},
        }




class StaleForMarginJSON(typing.TypedDict):
    kind: typing.Literal["StaleForMargin"]


@dataclass
class StaleForMargin:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> StaleForMarginJSON:
        return StaleForMarginJSON(
            kind="StaleForMargin",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "StaleForMargin": {},
        }




class InsufficientDataPointsJSON(typing.TypedDict):
    kind: typing.Literal["InsufficientDataPoints"]


@dataclass
class InsufficientDataPoints:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> InsufficientDataPointsJSON:
        return InsufficientDataPointsJSON(
            kind="InsufficientDataPoints",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "InsufficientDataPoints": {},
        }




class StaleForAMMJSON(typing.TypedDict):
    kind: typing.Literal["StaleForAMM"]


@dataclass
class StaleForAMM:
    discriminator: typing.ClassVar = 5
    def to_json(self) -> StaleForAMMJSON:
        return StaleForAMMJSON(
            kind="StaleForAMM",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "StaleForAMM": {},
        }




class ValidJSON(typing.TypedDict):
    kind: typing.Literal["Valid"]


@dataclass
class Valid:
    discriminator: typing.ClassVar = 6
    def to_json(self) -> ValidJSON:
        return ValidJSON(
            kind="Valid",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Valid": {},
        }





OracleValidityKind = typing.Union[
    NonPositive,
    TooVolatile,
    TooUncertain,
    StaleForMargin,
    InsufficientDataPoints,
    StaleForAMM,
    Valid,
]
OracleValidityJSON = typing.Union[
    NonPositiveJSON,
    TooVolatileJSON,
    TooUncertainJSON,
    StaleForMarginJSON,
    InsufficientDataPointsJSON,
    StaleForAMMJSON,
    ValidJSON,
]

def from_decoded(obj: dict) -> OracleValidityKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "NonPositive" in obj:
      return NonPositive()
    if "TooVolatile" in obj:
      return TooVolatile()
    if "TooUncertain" in obj:
      return TooUncertain()
    if "StaleForMargin" in obj:
      return StaleForMargin()
    if "InsufficientDataPoints" in obj:
      return InsufficientDataPoints()
    if "StaleForAMM" in obj:
      return StaleForAMM()
    if "Valid" in obj:
      return Valid()
    raise ValueError("Invalid enum object")

def from_json(obj: OracleValidityJSON) -> OracleValidityKind:
    if obj["kind"] == "NonPositive":
        return NonPositive()

    if obj["kind"] == "TooVolatile":
        return TooVolatile()

    if obj["kind"] == "TooUncertain":
        return TooUncertain()

    if obj["kind"] == "StaleForMargin":
        return StaleForMargin()

    if obj["kind"] == "InsufficientDataPoints":
        return InsufficientDataPoints()

    if obj["kind"] == "StaleForAMM":
        return StaleForAMM()

    if obj["kind"] == "Valid":
        return Valid()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"NonPositive" / borsh.CStruct(),
"TooVolatile" / borsh.CStruct(),
"TooUncertain" / borsh.CStruct(),
"StaleForMargin" / borsh.CStruct(),
"InsufficientDataPoints" / borsh.CStruct(),
"StaleForAMM" / borsh.CStruct(),
"Valid" / borsh.CStruct(),
)
