'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import EnumForCodegen
from dataclasses import dataclass


class SerumV3JSON(typing.TypedDict):
    kind: typing.Literal["SerumV3"]


@dataclass
class SerumV3:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> SerumV3JSON:
        return SerumV3JSON(
            kind="SerumV3",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "SerumV3": {},
        }




class MatchJSON(typing.TypedDict):
    kind: typing.Literal["Match"]


@dataclass
class Match:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> MatchJSON:
        return MatchJSON(
            kind="Match",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Match": {},
        }




class PhoenixV1JSON(typing.TypedDict):
    kind: typing.Literal["PhoenixV1"]


@dataclass
class PhoenixV1:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> PhoenixV1JSON:
        return PhoenixV1JSON(
            kind="PhoenixV1",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PhoenixV1": {},
        }




class OpenbookV2JSON(typing.TypedDict):
    kind: typing.Literal["OpenbookV2"]


@dataclass
class OpenbookV2:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> OpenbookV2JSON:
        return OpenbookV2JSON(
            kind="OpenbookV2",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OpenbookV2": {},
        }





SpotFulfillmentTypeKind = typing.Union[
    SerumV3,
    Match,
    PhoenixV1,
    OpenbookV2,
]
SpotFulfillmentTypeJSON = typing.Union[
    SerumV3JSON,
    MatchJSON,
    PhoenixV1JSON,
    OpenbookV2JSON,
]

def from_decoded(obj: dict) -> SpotFulfillmentTypeKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "SerumV3" in obj:
      return SerumV3()
    if "Match" in obj:
      return Match()
    if "PhoenixV1" in obj:
      return PhoenixV1()
    if "OpenbookV2" in obj:
      return OpenbookV2()
    raise ValueError("Invalid enum object")

def from_json(obj: SpotFulfillmentTypeJSON) -> SpotFulfillmentTypeKind:
    if obj["kind"] == "SerumV3":
        return SerumV3()

    if obj["kind"] == "Match":
        return Match()

    if obj["kind"] == "PhoenixV1":
        return PhoenixV1()

    if obj["kind"] == "OpenbookV2":
        return OpenbookV2()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")


layout = EnumForCodegen(
"SerumV3" / borsh.CStruct(),
"Match" / borsh.CStruct(),
"PhoenixV1" / borsh.CStruct(),
"OpenbookV2" / borsh.CStruct(),
)
