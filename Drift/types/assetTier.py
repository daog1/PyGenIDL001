'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class CollateralJSON(typing.TypedDict):
    kind: typing.Literal["Collateral"]


@dataclass
class Collateral:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> CollateralJSON:
        return CollateralJSON(
            kind="Collateral",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Collateral": {},
        }



class ProtectedJSON(typing.TypedDict):
    kind: typing.Literal["Protected"]


@dataclass
class Protected:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> ProtectedJSON:
        return ProtectedJSON(
            kind="Protected",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Protected": {},
        }



class CrossJSON(typing.TypedDict):
    kind: typing.Literal["Cross"]


@dataclass
class Cross:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> CrossJSON:
        return CrossJSON(
            kind="Cross",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Cross": {},
        }



class IsolatedJSON(typing.TypedDict):
    kind: typing.Literal["Isolated"]


@dataclass
class Isolated:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> IsolatedJSON:
        return IsolatedJSON(
            kind="Isolated",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Isolated": {},
        }



class UnlistedJSON(typing.TypedDict):
    kind: typing.Literal["Unlisted"]


@dataclass
class Unlisted:
    discriminator: typing.ClassVar = 4
    @classmethod
    def to_json(cls) -> UnlistedJSON:
        return UnlistedJSON(
            kind="Unlisted",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Unlisted": {},
        }





AssetTierKind = typing.Union[
Collateral,
Protected,
Cross,
Isolated,
Unlisted,
]
AssetTierJSON = typing.Union[
CollateralJSON,
ProtectedJSON,
CrossJSON,
IsolatedJSON,
UnlistedJSON,
]

def from_decoded(obj: dict) -> AssetTierKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Collateral" in obj:
      return Collateral()
    if "Protected" in obj:
      return Protected()
    if "Cross" in obj:
      return Cross()
    if "Isolated" in obj:
      return Isolated()
    if "Unlisted" in obj:
      return Unlisted()
    raise ValueError("Invalid enum object")

def from_json(obj: AssetTierJSON) -> AssetTierKind:
    if obj["kind"] == "Collateral":
        return Collateral()
    if obj["kind"] == "Protected":
        return Protected()
    if obj["kind"] == "Cross":
        return Cross()
    if obj["kind"] == "Isolated":
        return Isolated()
    if obj["kind"] == "Unlisted":
        return Unlisted()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Collateral" / borsh.CStruct(),
"Protected" / borsh.CStruct(),
"Cross" / borsh.CStruct(),
"Isolated" / borsh.CStruct(),
"Unlisted" / borsh.CStruct(),
)
