'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;
from solders.sysvar import RENT;


class CollateralJSON(typing.TypedDict):
    kind: typing.Literal["Collateral"]


@dataclass
class Collateral:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> CollateralJSON:
        return CollateralJSON(
            kind="Collateral",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Collateral": {},
        }




class ProtectedJSON(typing.TypedDict):
    kind: typing.Literal["Protected"]


@dataclass
class Protected:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> ProtectedJSON:
        return ProtectedJSON(
            kind="Protected",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Protected": {},
        }




class CrossJSON(typing.TypedDict):
    kind: typing.Literal["Cross"]


@dataclass
class Cross:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> CrossJSON:
        return CrossJSON(
            kind="Cross",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Cross": {},
        }




class IsolatedJSON(typing.TypedDict):
    kind: typing.Literal["Isolated"]


@dataclass
class Isolated:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> IsolatedJSON:
        return IsolatedJSON(
            kind="Isolated",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Isolated": {},
        }




class UnlistedJSON(typing.TypedDict):
    kind: typing.Literal["Unlisted"]


@dataclass
class Unlisted:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> UnlistedJSON:
        return UnlistedJSON(
            kind="Unlisted",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Unlisted": {},
        }





AssetTierKind = typing.Union[
    Collateral,
    Protected,
    Cross,
    Isolated,
    Unlisted,
]
AssetTierJSON = typing.Union[
    CollateralJSON,
    ProtectedJSON,
    CrossJSON,
    IsolatedJSON,
    UnlistedJSON,
]

def from_decoded(obj: dict) -> AssetTierKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Collateral" in obj:
      return Collateral()
    if "Protected" in obj:
      return Protected()
    if "Cross" in obj:
      return Cross()
    if "Isolated" in obj:
      return Isolated()
    if "Unlisted" in obj:
      return Unlisted()
    raise ValueError("Invalid enum object")

def from_json(obj: AssetTierJSON) -> AssetTierKind:
    if obj["kind"] == "Collateral":
        return Collateral()

    if obj["kind"] == "Protected":
        return Protected()

    if obj["kind"] == "Cross":
        return Cross()

    if obj["kind"] == "Isolated":
        return Isolated()

    if obj["kind"] == "Unlisted":
        return Unlisted()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Collateral" / borsh.CStruct(),
"Protected" / borsh.CStruct(),
"Cross" / borsh.CStruct(),
"Isolated" / borsh.CStruct(),
"Unlisted" / borsh.CStruct(),
)
