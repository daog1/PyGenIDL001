'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class UpdateFundingJSON(typing.TypedDict):
    kind: typing.Literal["UpdateFunding"]


@dataclass
class UpdateFunding:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> UpdateFundingJSON:
        return UpdateFundingJSON(
            kind="UpdateFunding",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "UpdateFunding": {},
        }



class AmmFillJSON(typing.TypedDict):
    kind: typing.Literal["AmmFill"]


@dataclass
class AmmFill:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> AmmFillJSON:
        return AmmFillJSON(
            kind="AmmFill",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "AmmFill": {},
        }



class FillJSON(typing.TypedDict):
    kind: typing.Literal["Fill"]


@dataclass
class Fill:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> FillJSON:
        return FillJSON(
            kind="Fill",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Fill": {},
        }



class SettlePnlJSON(typing.TypedDict):
    kind: typing.Literal["SettlePnl"]


@dataclass
class SettlePnl:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> SettlePnlJSON:
        return SettlePnlJSON(
            kind="SettlePnl",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "SettlePnl": {},
        }



class SettlePnlWithPositionJSON(typing.TypedDict):
    kind: typing.Literal["SettlePnlWithPosition"]


@dataclass
class SettlePnlWithPosition:
    discriminator: typing.ClassVar = 4
    @classmethod
    def to_json(cls) -> SettlePnlWithPositionJSON:
        return SettlePnlWithPositionJSON(
            kind="SettlePnlWithPosition",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "SettlePnlWithPosition": {},
        }



class LiquidationJSON(typing.TypedDict):
    kind: typing.Literal["Liquidation"]


@dataclass
class Liquidation:
    discriminator: typing.ClassVar = 5
    @classmethod
    def to_json(cls) -> LiquidationJSON:
        return LiquidationJSON(
            kind="Liquidation",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Liquidation": {},
        }



class AmmImmediateFillJSON(typing.TypedDict):
    kind: typing.Literal["AmmImmediateFill"]


@dataclass
class AmmImmediateFill:
    discriminator: typing.ClassVar = 6
    @classmethod
    def to_json(cls) -> AmmImmediateFillJSON:
        return AmmImmediateFillJSON(
            kind="AmmImmediateFill",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "AmmImmediateFill": {},
        }





PerpOperationKind = typing.Union[
UpdateFunding,
AmmFill,
Fill,
SettlePnl,
SettlePnlWithPosition,
Liquidation,
AmmImmediateFill,
]
PerpOperationJSON = typing.Union[
UpdateFundingJSON,
AmmFillJSON,
FillJSON,
SettlePnlJSON,
SettlePnlWithPositionJSON,
LiquidationJSON,
AmmImmediateFillJSON,
]

def from_decoded(obj: dict) -> PerpOperationKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "UpdateFunding" in obj:
      return UpdateFunding()
    if "AmmFill" in obj:
      return AmmFill()
    if "Fill" in obj:
      return Fill()
    if "SettlePnl" in obj:
      return SettlePnl()
    if "SettlePnlWithPosition" in obj:
      return SettlePnlWithPosition()
    if "Liquidation" in obj:
      return Liquidation()
    if "AmmImmediateFill" in obj:
      return AmmImmediateFill()
    raise ValueError("Invalid enum object")

def from_json(obj: PerpOperationJSON) -> PerpOperationKind:
    if obj["kind"] == "UpdateFunding":
        return UpdateFunding()
    if obj["kind"] == "AmmFill":
        return AmmFill()
    if obj["kind"] == "Fill":
        return Fill()
    if obj["kind"] == "SettlePnl":
        return SettlePnl()
    if obj["kind"] == "SettlePnlWithPosition":
        return SettlePnlWithPosition()
    if obj["kind"] == "Liquidation":
        return Liquidation()
    if obj["kind"] == "AmmImmediateFill":
        return AmmImmediateFill()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"UpdateFunding" / borsh.CStruct(),
"AmmFill" / borsh.CStruct(),
"Fill" / borsh.CStruct(),
"SettlePnl" / borsh.CStruct(),
"SettlePnlWithPosition" / borsh.CStruct(),
"Liquidation" / borsh.CStruct(),
"AmmImmediateFill" / borsh.CStruct(),
)
