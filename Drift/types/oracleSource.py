'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import EnumForCodegen
from dataclasses import dataclass


class PythJSON(typing.TypedDict):
    kind: typing.Literal["Pyth"]


@dataclass
class Pyth:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> PythJSON:
        return PythJSON(
            kind="Pyth",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Pyth": {},
        }




class SwitchboardJSON(typing.TypedDict):
    kind: typing.Literal["Switchboard"]


@dataclass
class Switchboard:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> SwitchboardJSON:
        return SwitchboardJSON(
            kind="Switchboard",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Switchboard": {},
        }




class QuoteAssetJSON(typing.TypedDict):
    kind: typing.Literal["QuoteAsset"]


@dataclass
class QuoteAsset:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> QuoteAssetJSON:
        return QuoteAssetJSON(
            kind="QuoteAsset",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "QuoteAsset": {},
        }




class Pyth1KJSON(typing.TypedDict):
    kind: typing.Literal["Pyth1K"]


@dataclass
class Pyth1K:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> Pyth1KJSON:
        return Pyth1KJSON(
            kind="Pyth1K",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Pyth1K": {},
        }




class Pyth1MJSON(typing.TypedDict):
    kind: typing.Literal["Pyth1M"]


@dataclass
class Pyth1M:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> Pyth1MJSON:
        return Pyth1MJSON(
            kind="Pyth1M",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Pyth1M": {},
        }




class PythStableCoinJSON(typing.TypedDict):
    kind: typing.Literal["PythStableCoin"]


@dataclass
class PythStableCoin:
    discriminator: typing.ClassVar = 5
    def to_json(self) -> PythStableCoinJSON:
        return PythStableCoinJSON(
            kind="PythStableCoin",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PythStableCoin": {},
        }




class PrelaunchJSON(typing.TypedDict):
    kind: typing.Literal["Prelaunch"]


@dataclass
class Prelaunch:
    discriminator: typing.ClassVar = 6
    def to_json(self) -> PrelaunchJSON:
        return PrelaunchJSON(
            kind="Prelaunch",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Prelaunch": {},
        }




class PythPullJSON(typing.TypedDict):
    kind: typing.Literal["PythPull"]


@dataclass
class PythPull:
    discriminator: typing.ClassVar = 7
    def to_json(self) -> PythPullJSON:
        return PythPullJSON(
            kind="PythPull",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PythPull": {},
        }




class Pyth1KPullJSON(typing.TypedDict):
    kind: typing.Literal["Pyth1KPull"]


@dataclass
class Pyth1KPull:
    discriminator: typing.ClassVar = 8
    def to_json(self) -> Pyth1KPullJSON:
        return Pyth1KPullJSON(
            kind="Pyth1KPull",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Pyth1KPull": {},
        }




class Pyth1MPullJSON(typing.TypedDict):
    kind: typing.Literal["Pyth1MPull"]


@dataclass
class Pyth1MPull:
    discriminator: typing.ClassVar = 9
    def to_json(self) -> Pyth1MPullJSON:
        return Pyth1MPullJSON(
            kind="Pyth1MPull",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Pyth1MPull": {},
        }




class PythStableCoinPullJSON(typing.TypedDict):
    kind: typing.Literal["PythStableCoinPull"]


@dataclass
class PythStableCoinPull:
    discriminator: typing.ClassVar = 10
    def to_json(self) -> PythStableCoinPullJSON:
        return PythStableCoinPullJSON(
            kind="PythStableCoinPull",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PythStableCoinPull": {},
        }




class SwitchboardOnDemandJSON(typing.TypedDict):
    kind: typing.Literal["SwitchboardOnDemand"]


@dataclass
class SwitchboardOnDemand:
    discriminator: typing.ClassVar = 11
    def to_json(self) -> SwitchboardOnDemandJSON:
        return SwitchboardOnDemandJSON(
            kind="SwitchboardOnDemand",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "SwitchboardOnDemand": {},
        }




class PythLazerJSON(typing.TypedDict):
    kind: typing.Literal["PythLazer"]


@dataclass
class PythLazer:
    discriminator: typing.ClassVar = 12
    def to_json(self) -> PythLazerJSON:
        return PythLazerJSON(
            kind="PythLazer",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PythLazer": {},
        }





OracleSourceKind = typing.Union[
    Pyth,
    Switchboard,
    QuoteAsset,
    Pyth1K,
    Pyth1M,
    PythStableCoin,
    Prelaunch,
    PythPull,
    Pyth1KPull,
    Pyth1MPull,
    PythStableCoinPull,
    SwitchboardOnDemand,
    PythLazer,
]
OracleSourceJSON = typing.Union[
    PythJSON,
    SwitchboardJSON,
    QuoteAssetJSON,
    Pyth1KJSON,
    Pyth1MJSON,
    PythStableCoinJSON,
    PrelaunchJSON,
    PythPullJSON,
    Pyth1KPullJSON,
    Pyth1MPullJSON,
    PythStableCoinPullJSON,
    SwitchboardOnDemandJSON,
    PythLazerJSON,
]

def from_decoded(obj: dict) -> OracleSourceKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Pyth" in obj:
      return Pyth()
    if "Switchboard" in obj:
      return Switchboard()
    if "QuoteAsset" in obj:
      return QuoteAsset()
    if "Pyth1K" in obj:
      return Pyth1K()
    if "Pyth1M" in obj:
      return Pyth1M()
    if "PythStableCoin" in obj:
      return PythStableCoin()
    if "Prelaunch" in obj:
      return Prelaunch()
    if "PythPull" in obj:
      return PythPull()
    if "Pyth1KPull" in obj:
      return Pyth1KPull()
    if "Pyth1MPull" in obj:
      return Pyth1MPull()
    if "PythStableCoinPull" in obj:
      return PythStableCoinPull()
    if "SwitchboardOnDemand" in obj:
      return SwitchboardOnDemand()
    if "PythLazer" in obj:
      return PythLazer()
    raise ValueError("Invalid enum object")

def from_json(obj: OracleSourceJSON) -> OracleSourceKind:
    if obj["kind"] == "Pyth":
        return Pyth()

    if obj["kind"] == "Switchboard":
        return Switchboard()

    if obj["kind"] == "QuoteAsset":
        return QuoteAsset()

    if obj["kind"] == "Pyth1K":
        return Pyth1K()

    if obj["kind"] == "Pyth1M":
        return Pyth1M()

    if obj["kind"] == "PythStableCoin":
        return PythStableCoin()

    if obj["kind"] == "Prelaunch":
        return Prelaunch()

    if obj["kind"] == "PythPull":
        return PythPull()

    if obj["kind"] == "Pyth1KPull":
        return Pyth1KPull()

    if obj["kind"] == "Pyth1MPull":
        return Pyth1MPull()

    if obj["kind"] == "PythStableCoinPull":
        return PythStableCoinPull()

    if obj["kind"] == "SwitchboardOnDemand":
        return SwitchboardOnDemand()

    if obj["kind"] == "PythLazer":
        return PythLazer()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")


layout = EnumForCodegen(
"Pyth" / borsh.CStruct(),
"Switchboard" / borsh.CStruct(),
"QuoteAsset" / borsh.CStruct(),
"Pyth1K" / borsh.CStruct(),
"Pyth1M" / borsh.CStruct(),
"PythStableCoin" / borsh.CStruct(),
"Prelaunch" / borsh.CStruct(),
"PythPull" / borsh.CStruct(),
"Pyth1KPull" / borsh.CStruct(),
"Pyth1MPull" / borsh.CStruct(),
"PythStableCoinPull" / borsh.CStruct(),
"SwitchboardOnDemand" / borsh.CStruct(),
"PythLazer" / borsh.CStruct(),
)
