'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class FillJSON(typing.TypedDict):
    kind: typing.Literal["Fill"]


@dataclass
class Fill:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> FillJSON:
        return FillJSON(
            kind="Fill",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Fill": {},
        }



class PlaceAndMakeJSON(typing.TypedDict):
    kind: typing.Literal["PlaceAndMake"]


@dataclass
class PlaceAndMake:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> PlaceAndMakeJSON:
        return PlaceAndMakeJSON(
            kind="PlaceAndMake",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "PlaceAndMake": {},
        }



class PlaceAndTakeJSON(typing.TypedDict):
    kind: typing.Literal["PlaceAndTake"]


@dataclass
class PlaceAndTake:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> PlaceAndTakeJSON:
        return PlaceAndTakeJSON(
            kind="PlaceAndTake",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "PlaceAndTake": {},
        }



class LiquidationJSON(typing.TypedDict):
    kind: typing.Literal["Liquidation"]


@dataclass
class Liquidation:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> LiquidationJSON:
        return LiquidationJSON(
            kind="Liquidation",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Liquidation": {},
        }



class RFQJSON(typing.TypedDict):
    kind: typing.Literal["RFQ"]


@dataclass
class RFQ:
    discriminator: typing.ClassVar = 4
    @classmethod
    def to_json(cls) -> RFQJSON:
        return RFQJSON(
            kind="RFQ",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "RFQ": {},
        }





FillModeKind = typing.Union[
Fill,
PlaceAndMake,
PlaceAndTake,
Liquidation,
RFQ,
]
FillModeJSON = typing.Union[
FillJSON,
PlaceAndMakeJSON,
PlaceAndTakeJSON,
LiquidationJSON,
RFQJSON,
]

def from_decoded(obj: dict) -> FillModeKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Fill" in obj:
      return Fill()
    if "PlaceAndMake" in obj:
      return PlaceAndMake()
    if "PlaceAndTake" in obj:
      return PlaceAndTake()
    if "Liquidation" in obj:
      return Liquidation()
    if "RFQ" in obj:
      return RFQ()
    raise ValueError("Invalid enum object")

def from_json(obj: FillModeJSON) -> FillModeKind:
    if obj["kind"] == "Fill":
        return Fill()
    if obj["kind"] == "PlaceAndMake":
        return PlaceAndMake()
    if obj["kind"] == "PlaceAndTake":
        return PlaceAndTake()
    if obj["kind"] == "Liquidation":
        return Liquidation()
    if obj["kind"] == "RFQ":
        return RFQ()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Fill" / borsh.CStruct(),
"PlaceAndMake" / borsh.CStruct(),
"PlaceAndTake" / borsh.CStruct(),
"Liquidation" / borsh.CStruct(),
"RFQ" / borsh.CStruct(),
)
