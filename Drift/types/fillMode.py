'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;
from solders.sysvar import RENT;


class FillJSON(typing.TypedDict):
    kind: typing.Literal["Fill"]


@dataclass
class Fill:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> FillJSON:
        return FillJSON(
            kind="Fill",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Fill": {},
        }




class PlaceAndMakeJSON(typing.TypedDict):
    kind: typing.Literal["PlaceAndMake"]


@dataclass
class PlaceAndMake:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> PlaceAndMakeJSON:
        return PlaceAndMakeJSON(
            kind="PlaceAndMake",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PlaceAndMake": {},
        }



PlaceAndTakeJSONValue = tuple[bool,int]
PlaceAndTakeValue = tuple[bool,int]

class PlaceAndTakeJSON(typing.TypedDict):
    kind: typing.Literal["PlaceAndTake"]
    value: PlaceAndTakeJSONValue


@dataclass
class PlaceAndTake:
    discriminator: typing.ClassVar = 2
    value : PlaceAndTakeValue
    def to_json(self) -> PlaceAndTakeJSON:
        return PlaceAndTakeJSON(
            kind="PlaceAndTake",
            value = (self.value[0],self.value[1],)
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PlaceAndTake": { "item_0":self.value[0],"item_1":self.value[1] }
        }




class LiquidationJSON(typing.TypedDict):
    kind: typing.Literal["Liquidation"]


@dataclass
class Liquidation:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> LiquidationJSON:
        return LiquidationJSON(
            kind="Liquidation",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Liquidation": {},
        }




class RFQJSON(typing.TypedDict):
    kind: typing.Literal["RFQ"]


@dataclass
class RFQ:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> RFQJSON:
        return RFQJSON(
            kind="RFQ",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "RFQ": {},
        }





FillModeKind = typing.Union[
    Fill,
    PlaceAndMake,
    PlaceAndTake,
    Liquidation,
    RFQ,
]
FillModeJSON = typing.Union[
    FillJSON,
    PlaceAndMakeJSON,
    PlaceAndTakeJSON,
    LiquidationJSON,
    RFQJSON,
]

def from_decoded(obj: dict) -> FillModeKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Fill" in obj:
      return Fill()
    if "PlaceAndMake" in obj:
      return PlaceAndMake()
    if "PlaceAndTake" in obj:
      val = obj["PlaceAndTake"]
      return PlaceAndTake((
      val["item_0"],val["item_1"],
      ))
    if "Liquidation" in obj:
      return Liquidation()
    if "RFQ" in obj:
      return RFQ()
    raise ValueError("Invalid enum object")

def from_json(obj: FillModeJSON) -> FillModeKind:
    if obj["kind"] == "Fill":
        return Fill()

    if obj["kind"] == "PlaceAndMake":
        return PlaceAndMake()

    if obj["kind"] == "PlaceAndTake":
        placeAndTakeJSONValue = typing.cast(PlaceAndTakeJSONValue, obj["value"])
        return PlaceAndTake(
        (placeAndTakeJSONValue[0],placeAndTakeJSONValue[1],)
        )

    if obj["kind"] == "Liquidation":
        return Liquidation()

    if obj["kind"] == "RFQ":
        return RFQ()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Fill" / borsh.CStruct(),
"PlaceAndMake" / borsh.CStruct(),
"PlaceAndTake" / borsh.CStruct("item_0" / borsh.Bool,"item_1" / borsh.U8,),
"Liquidation" / borsh.CStruct(),
"RFQ" / borsh.CStruct(),
)
