'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;
from solders.sysvar import RENT;
from . import marketIdentifier;

class StandardJSONValue(typing.TypedDict):
    trackOpenOrdersFraction: bool
class StandardValue(typing.TypedDict):
    trackOpenOrdersFraction: bool




class StandardJSON(typing.TypedDict):
    kind: typing.Literal["Standard"]
    value: StandardJSONValue


@dataclass
class Standard:
    discriminator: typing.ClassVar = 0
    value : StandardValue
    def to_json(self) -> StandardJSON:
        return StandardJSON(
            kind="Standard",
            value = {
            "trackOpenOrdersFraction":self.value["trackOpenOrdersFraction"]
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Standard":{ "trackOpenOrdersFraction":self.value["trackOpenOrdersFraction"] }
            }



class LiquidationJSONValue(typing.TypedDict):
    marketToTrackMarginRequirement: typing.Optional[marketIdentifier.MarketIdentifierJSON]
class LiquidationValue(typing.TypedDict):
    marketToTrackMarginRequirement: typing.Optional[marketIdentifier.MarketIdentifier]




class LiquidationJSON(typing.TypedDict):
    kind: typing.Literal["Liquidation"]
    value: LiquidationJSONValue


@dataclass
class Liquidation:
    discriminator: typing.ClassVar = 1
    value : LiquidationValue
    def to_json(self) -> LiquidationJSON:
        return LiquidationJSON(
            kind="Liquidation",
            value = {
            "marketToTrackMarginRequirement":(None if self.value["marketToTrackMarginRequirement"] is None else self.value["marketToTrackMarginRequirement"].to_json())
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Liquidation":{ "marketToTrackMarginRequirement":(None if self.value["marketToTrackMarginRequirement"] is None else self.value["marketToTrackMarginRequirement"].to_encodable()) }
            }





MarginCalculationModeKind = typing.Union[
    Standard,
    Liquidation,
]
MarginCalculationModeJSON = typing.Union[
    StandardJSON,
    LiquidationJSON,
]

def from_decoded(obj: dict) -> MarginCalculationModeKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Standard" in obj:
      val = obj["Standard"]
      return Standard(
            StandardValue(
                trackOpenOrdersFraction= val["trackOpenOrdersFraction"]
            )
        )

    if "Liquidation" in obj:
      val = obj["Liquidation"]
      return Liquidation(
            LiquidationValue(
                marketToTrackMarginRequirement= (None if val["marketToTrackMarginRequirement"] is None else marketIdentifier.MarketIdentifier.from_decoded(val["marketToTrackMarginRequirement"]))
            )
        )

    raise ValueError("Invalid enum object")

def from_json(obj: MarginCalculationModeJSON) -> MarginCalculationModeKind:
    if obj["kind"] == "Standard":
        standardJSONValue = typing.cast(StandardJSONValue, obj["value"])
        return Standard(
            StandardValue(
                trackOpenOrdersFraction=standardJSONValue["trackOpenOrdersFraction"]
            )
        )


    if obj["kind"] == "Liquidation":
        liquidationJSONValue = typing.cast(LiquidationJSONValue, obj["value"])
        return Liquidation(
            LiquidationValue(
                marketToTrackMarginRequirement=(None if liquidationJSONValue["marketToTrackMarginRequirement"] is None else marketIdentifier.MarketIdentifier.from_json(liquidationJSONValue["marketToTrackMarginRequirement"]))
            )
        )


    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"Standard" / borsh.CStruct("trackOpenOrdersFraction" /borsh.Bool),
"Liquidation" / borsh.CStruct("marketToTrackMarginRequirement" /borsh.Option(marketIdentifier.MarketIdentifier.layout)),
)
