'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey as SolPubkey;
from solders.sysvar import RENT;


class UpdateFundingJSON(typing.TypedDict):
    kind: typing.Literal["UpdateFunding"]


@dataclass
class UpdateFunding:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> UpdateFundingJSON:
        return UpdateFundingJSON(
            kind="UpdateFunding",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "UpdateFunding": {},
        }




class SettlePnlJSON(typing.TypedDict):
    kind: typing.Literal["SettlePnl"]


@dataclass
class SettlePnl:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> SettlePnlJSON:
        return SettlePnlJSON(
            kind="SettlePnl",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "SettlePnl": {},
        }




class TriggerOrderJSON(typing.TypedDict):
    kind: typing.Literal["TriggerOrder"]


@dataclass
class TriggerOrder:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> TriggerOrderJSON:
        return TriggerOrderJSON(
            kind="TriggerOrder",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "TriggerOrder": {},
        }




class FillOrderMatchJSON(typing.TypedDict):
    kind: typing.Literal["FillOrderMatch"]


@dataclass
class FillOrderMatch:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> FillOrderMatchJSON:
        return FillOrderMatchJSON(
            kind="FillOrderMatch",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "FillOrderMatch": {},
        }




class FillOrderAmmJSON(typing.TypedDict):
    kind: typing.Literal["FillOrderAmm"]


@dataclass
class FillOrderAmm:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> FillOrderAmmJSON:
        return FillOrderAmmJSON(
            kind="FillOrderAmm",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "FillOrderAmm": {},
        }




class LiquidateJSON(typing.TypedDict):
    kind: typing.Literal["Liquidate"]


@dataclass
class Liquidate:
    discriminator: typing.ClassVar = 5
    def to_json(self) -> LiquidateJSON:
        return LiquidateJSON(
            kind="Liquidate",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Liquidate": {},
        }




class MarginCalcJSON(typing.TypedDict):
    kind: typing.Literal["MarginCalc"]


@dataclass
class MarginCalc:
    discriminator: typing.ClassVar = 6
    def to_json(self) -> MarginCalcJSON:
        return MarginCalcJSON(
            kind="MarginCalc",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "MarginCalc": {},
        }




class UpdateTwapJSON(typing.TypedDict):
    kind: typing.Literal["UpdateTwap"]


@dataclass
class UpdateTwap:
    discriminator: typing.ClassVar = 7
    def to_json(self) -> UpdateTwapJSON:
        return UpdateTwapJSON(
            kind="UpdateTwap",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "UpdateTwap": {},
        }




class UpdateAMMCurveJSON(typing.TypedDict):
    kind: typing.Literal["UpdateAMMCurve"]


@dataclass
class UpdateAMMCurve:
    discriminator: typing.ClassVar = 8
    def to_json(self) -> UpdateAMMCurveJSON:
        return UpdateAMMCurveJSON(
            kind="UpdateAMMCurve",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "UpdateAMMCurve": {},
        }




class OracleOrderPriceJSON(typing.TypedDict):
    kind: typing.Literal["OracleOrderPrice"]


@dataclass
class OracleOrderPrice:
    discriminator: typing.ClassVar = 9
    def to_json(self) -> OracleOrderPriceJSON:
        return OracleOrderPriceJSON(
            kind="OracleOrderPrice",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OracleOrderPrice": {},
        }





DriftActionKind = typing.Union[
    UpdateFunding,
    SettlePnl,
    TriggerOrder,
    FillOrderMatch,
    FillOrderAmm,
    Liquidate,
    MarginCalc,
    UpdateTwap,
    UpdateAMMCurve,
    OracleOrderPrice,
]
DriftActionJSON = typing.Union[
    UpdateFundingJSON,
    SettlePnlJSON,
    TriggerOrderJSON,
    FillOrderMatchJSON,
    FillOrderAmmJSON,
    LiquidateJSON,
    MarginCalcJSON,
    UpdateTwapJSON,
    UpdateAMMCurveJSON,
    OracleOrderPriceJSON,
]

def from_decoded(obj: dict) -> DriftActionKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "UpdateFunding" in obj:
      return UpdateFunding()
    if "SettlePnl" in obj:
      return SettlePnl()
    if "TriggerOrder" in obj:
      return TriggerOrder()
    if "FillOrderMatch" in obj:
      return FillOrderMatch()
    if "FillOrderAmm" in obj:
      return FillOrderAmm()
    if "Liquidate" in obj:
      return Liquidate()
    if "MarginCalc" in obj:
      return MarginCalc()
    if "UpdateTwap" in obj:
      return UpdateTwap()
    if "UpdateAMMCurve" in obj:
      return UpdateAMMCurve()
    if "OracleOrderPrice" in obj:
      return OracleOrderPrice()
    raise ValueError("Invalid enum object")

def from_json(obj: DriftActionJSON) -> DriftActionKind:
    if obj["kind"] == "UpdateFunding":
        return UpdateFunding()

    if obj["kind"] == "SettlePnl":
        return SettlePnl()

    if obj["kind"] == "TriggerOrder":
        return TriggerOrder()

    if obj["kind"] == "FillOrderMatch":
        return FillOrderMatch()

    if obj["kind"] == "FillOrderAmm":
        return FillOrderAmm()

    if obj["kind"] == "Liquidate":
        return Liquidate()

    if obj["kind"] == "MarginCalc":
        return MarginCalc()

    if obj["kind"] == "UpdateTwap":
        return UpdateTwap()

    if obj["kind"] == "UpdateAMMCurve":
        return UpdateAMMCurve()

    if obj["kind"] == "OracleOrderPrice":
        return OracleOrderPrice()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"UpdateFunding" / borsh.CStruct(),
"SettlePnl" / borsh.CStruct(),
"TriggerOrder" / borsh.CStruct(),
"FillOrderMatch" / borsh.CStruct(),
"FillOrderAmm" / borsh.CStruct(),
"Liquidate" / borsh.CStruct(),
"MarginCalc" / borsh.CStruct(),
"UpdateTwap" / borsh.CStruct(),
"UpdateAMMCurve" / borsh.CStruct(),
"OracleOrderPrice" / borsh.CStruct(),
)
