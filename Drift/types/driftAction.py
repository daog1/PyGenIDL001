'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh;
import typing;
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen;
from construct import Container;
from dataclasses import dataclass;
from solders.pubkey import Pubkey;
from solders.sysvar import RENT;

class UpdateFundingJSON(typing.TypedDict):
    kind: typing.Literal["UpdateFunding"]


@dataclass
class UpdateFunding:
    discriminator: typing.ClassVar = 0
    @classmethod
    def to_json(cls) -> UpdateFundingJSON:
        return UpdateFundingJSON(
            kind="UpdateFunding",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "UpdateFunding": {},
        }



class SettlePnlJSON(typing.TypedDict):
    kind: typing.Literal["SettlePnl"]


@dataclass
class SettlePnl:
    discriminator: typing.ClassVar = 1
    @classmethod
    def to_json(cls) -> SettlePnlJSON:
        return SettlePnlJSON(
            kind="SettlePnl",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "SettlePnl": {},
        }



class TriggerOrderJSON(typing.TypedDict):
    kind: typing.Literal["TriggerOrder"]


@dataclass
class TriggerOrder:
    discriminator: typing.ClassVar = 2
    @classmethod
    def to_json(cls) -> TriggerOrderJSON:
        return TriggerOrderJSON(
            kind="TriggerOrder",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "TriggerOrder": {},
        }



class FillOrderMatchJSON(typing.TypedDict):
    kind: typing.Literal["FillOrderMatch"]


@dataclass
class FillOrderMatch:
    discriminator: typing.ClassVar = 3
    @classmethod
    def to_json(cls) -> FillOrderMatchJSON:
        return FillOrderMatchJSON(
            kind="FillOrderMatch",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "FillOrderMatch": {},
        }



class FillOrderAmmJSON(typing.TypedDict):
    kind: typing.Literal["FillOrderAmm"]


@dataclass
class FillOrderAmm:
    discriminator: typing.ClassVar = 4
    @classmethod
    def to_json(cls) -> FillOrderAmmJSON:
        return FillOrderAmmJSON(
            kind="FillOrderAmm",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "FillOrderAmm": {},
        }



class LiquidateJSON(typing.TypedDict):
    kind: typing.Literal["Liquidate"]


@dataclass
class Liquidate:
    discriminator: typing.ClassVar = 5
    @classmethod
    def to_json(cls) -> LiquidateJSON:
        return LiquidateJSON(
            kind="Liquidate",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "Liquidate": {},
        }



class MarginCalcJSON(typing.TypedDict):
    kind: typing.Literal["MarginCalc"]


@dataclass
class MarginCalc:
    discriminator: typing.ClassVar = 6
    @classmethod
    def to_json(cls) -> MarginCalcJSON:
        return MarginCalcJSON(
            kind="MarginCalc",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "MarginCalc": {},
        }



class UpdateTwapJSON(typing.TypedDict):
    kind: typing.Literal["UpdateTwap"]


@dataclass
class UpdateTwap:
    discriminator: typing.ClassVar = 7
    @classmethod
    def to_json(cls) -> UpdateTwapJSON:
        return UpdateTwapJSON(
            kind="UpdateTwap",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "UpdateTwap": {},
        }



class UpdateAMMCurveJSON(typing.TypedDict):
    kind: typing.Literal["UpdateAMMCurve"]


@dataclass
class UpdateAMMCurve:
    discriminator: typing.ClassVar = 8
    @classmethod
    def to_json(cls) -> UpdateAMMCurveJSON:
        return UpdateAMMCurveJSON(
            kind="UpdateAMMCurve",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "UpdateAMMCurve": {},
        }



class OracleOrderPriceJSON(typing.TypedDict):
    kind: typing.Literal["OracleOrderPrice"]


@dataclass
class OracleOrderPrice:
    discriminator: typing.ClassVar = 9
    @classmethod
    def to_json(cls) -> OracleOrderPriceJSON:
        return OracleOrderPriceJSON(
            kind="OracleOrderPrice",
        )

    @classmethod
    def to_encodable(cls) -> dict:
        return {
            "OracleOrderPrice": {},
        }





DriftActionKind = typing.Union[
UpdateFunding,
SettlePnl,
TriggerOrder,
FillOrderMatch,
FillOrderAmm,
Liquidate,
MarginCalc,
UpdateTwap,
UpdateAMMCurve,
OracleOrderPrice,
]
DriftActionJSON = typing.Union[
UpdateFundingJSON,
SettlePnlJSON,
TriggerOrderJSON,
FillOrderMatchJSON,
FillOrderAmmJSON,
LiquidateJSON,
MarginCalcJSON,
UpdateTwapJSON,
UpdateAMMCurveJSON,
OracleOrderPriceJSON,
]

def from_decoded(obj: dict) -> DriftActionKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "UpdateFunding" in obj:
      return UpdateFunding()
    if "SettlePnl" in obj:
      return SettlePnl()
    if "TriggerOrder" in obj:
      return TriggerOrder()
    if "FillOrderMatch" in obj:
      return FillOrderMatch()
    if "FillOrderAmm" in obj:
      return FillOrderAmm()
    if "Liquidate" in obj:
      return Liquidate()
    if "MarginCalc" in obj:
      return MarginCalc()
    if "UpdateTwap" in obj:
      return UpdateTwap()
    if "UpdateAMMCurve" in obj:
      return UpdateAMMCurve()
    if "OracleOrderPrice" in obj:
      return OracleOrderPrice()
    raise ValueError("Invalid enum object")

def from_json(obj: DriftActionJSON) -> DriftActionKind:
    if obj["kind"] == "UpdateFunding":
        return UpdateFunding()
    if obj["kind"] == "SettlePnl":
        return SettlePnl()
    if obj["kind"] == "TriggerOrder":
        return TriggerOrder()
    if obj["kind"] == "FillOrderMatch":
        return FillOrderMatch()
    if obj["kind"] == "FillOrderAmm":
        return FillOrderAmm()
    if obj["kind"] == "Liquidate":
        return Liquidate()
    if obj["kind"] == "MarginCalc":
        return MarginCalc()
    if obj["kind"] == "UpdateTwap":
        return UpdateTwap()
    if obj["kind"] == "UpdateAMMCurve":
        return UpdateAMMCurve()
    if obj["kind"] == "OracleOrderPrice":
        return OracleOrderPrice()
    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")

layout = EnumForCodegen(
"UpdateFunding" / borsh.CStruct(),
"SettlePnl" / borsh.CStruct(),
"TriggerOrder" / borsh.CStruct(),
"FillOrderMatch" / borsh.CStruct(),
"FillOrderAmm" / borsh.CStruct(),
"Liquidate" / borsh.CStruct(),
"MarginCalc" / borsh.CStruct(),
"UpdateTwap" / borsh.CStruct(),
"UpdateAMMCurve" / borsh.CStruct(),
"OracleOrderPrice" / borsh.CStruct(),
)
