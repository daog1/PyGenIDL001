'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import BorshPubkey
from anchorpy.error import AccountInvalidDiscriminator
from anchorpy.utils.rpc import get_multiple_accounts
from dataclasses import dataclass
from solana.rpc.async_api import AsyncClient
from solana.rpc.commitment import Commitment
from solders.pubkey import Pubkey as SolPubkey
from .. import types
from ..program_id import PROGRAM_ID


class StateJSON(typing.TypedDict):
    admin: str
    whitelistMint: str
    discountMint: str
    signer: str
    srmVault: str
    perpFeeStructure: types.feeStructure.FeeStructureJSON
    spotFeeStructure: types.feeStructure.FeeStructureJSON
    oracleGuardRails: types.oracleGuardRails.OracleGuardRailsJSON
    numberOfAuthorities: int
    numberOfSubAccounts: int
    lpCooldownTime: int
    liquidationMarginBufferRatio: int
    settlementDuration: int
    numberOfMarkets: int
    numberOfSpotMarkets: int
    signerNonce: int
    minPerpAuctionDuration: int
    defaultMarketOrderTimeInForce: int
    defaultSpotAuctionDuration: int
    exchangeStatus: int
    liquidationDuration: int
    initialPctToLiquidate: int
    maxNumberOfSubAccounts: int
    maxInitializeUserFee: int
    padding: list[int]

@dataclass
class State:
    #fields
    admin: SolPubkey
    whitelistMint: SolPubkey
    discountMint: SolPubkey
    signer: SolPubkey
    srmVault: SolPubkey
    perpFeeStructure: types.feeStructure.FeeStructure
    spotFeeStructure: types.feeStructure.FeeStructure
    oracleGuardRails: types.oracleGuardRails.OracleGuardRails
    numberOfAuthorities: int
    numberOfSubAccounts: int
    lpCooldownTime: int
    liquidationMarginBufferRatio: int
    settlementDuration: int
    numberOfMarkets: int
    numberOfSpotMarkets: int
    signerNonce: int
    minPerpAuctionDuration: int
    defaultMarketOrderTimeInForce: int
    defaultSpotAuctionDuration: int
    exchangeStatus: int
    liquidationDuration: int
    initialPctToLiquidate: int
    maxNumberOfSubAccounts: int
    maxInitializeUserFee: int
    padding: list[int]

    discriminator: typing.ClassVar = b"\xd8\x92\x6b\x5e\x68\x4b\xb6\xb1"
    DISCRIMINATOR_SIZE: int = 8

    layout: typing.ClassVar = borsh.CStruct(
        "admin" /BorshPubkey,
        "whitelistMint" /BorshPubkey,
        "discountMint" /BorshPubkey,
        "signer" /BorshPubkey,
        "srmVault" /BorshPubkey,
        "perpFeeStructure" /types.feeStructure.FeeStructure.layout,
        "spotFeeStructure" /types.feeStructure.FeeStructure.layout,
        "oracleGuardRails" /types.oracleGuardRails.OracleGuardRails.layout,
        "numberOfAuthorities" /borsh.U64,
        "numberOfSubAccounts" /borsh.U64,
        "lpCooldownTime" /borsh.U64,
        "liquidationMarginBufferRatio" /borsh.U32,
        "settlementDuration" /borsh.U16,
        "numberOfMarkets" /borsh.U16,
        "numberOfSpotMarkets" /borsh.U16,
        "signerNonce" /borsh.U8,
        "minPerpAuctionDuration" /borsh.U8,
        "defaultMarketOrderTimeInForce" /borsh.U8,
        "defaultSpotAuctionDuration" /borsh.U8,
        "exchangeStatus" /borsh.U8,
        "liquidationDuration" /borsh.U8,
        "initialPctToLiquidate" /borsh.U16,
        "maxNumberOfSubAccounts" /borsh.U16,
        "maxInitializeUserFee" /borsh.U16,
        "padding" /borsh.U8[10],
        )



    @classmethod
    async def fetch(
        cls,
        conn: AsyncClient,
        address: SolPubkey,
        commitment: typing.Optional[Commitment] = None,
        program_id: SolPubkey = PROGRAM_ID,
    ) -> typing.Optional["State"]:
        resp = await conn.get_account_info(address, commitment=commitment)
        info = resp.value
        if info is None:
            return None
        if info.owner != program_id:
            raise ValueError("Account does not belong to this program")
        bytes_data = info.data
        return cls.decode(bytes_data)

    @classmethod
    async def fetch_multiple(
        cls,
        conn: AsyncClient,
        addresses: list[SolPubkey],
        commitment: typing.Optional[Commitment] = None,
        program_id: SolPubkey = PROGRAM_ID,
    ) -> typing.List[typing.Optional["State"]]:
        infos = await get_multiple_accounts(conn, addresses, commitment=commitment)
        res: typing.List[typing.Optional["State"]] = []
        for info in infos:
            if info is None:
                res.append(None)
                continue
            if info.account.owner != program_id:
                raise ValueError("Account does not belong to this program")
            res.append(cls.decode(info.account.data))
        return res

    @classmethod
    def decode(cls, data: bytes) -> "State":
        if data[:cls.DISCRIMINATOR_SIZE] != cls.discriminator:
            raise AccountInvalidDiscriminator(
                "The discriminator for this account is invalid"
            )
        dec = State.layout.parse(data[cls.DISCRIMINATOR_SIZE:])
        return cls(
                admin=dec.admin,
                whitelistMint=dec.whitelistMint,
                discountMint=dec.discountMint,
                signer=dec.signer,
                srmVault=dec.srmVault,
                perpFeeStructure=types.feeStructure.FeeStructure.from_decoded(dec.perpFeeStructure),
                spotFeeStructure=types.feeStructure.FeeStructure.from_decoded(dec.spotFeeStructure),
                oracleGuardRails=types.oracleGuardRails.OracleGuardRails.from_decoded(dec.oracleGuardRails),
                numberOfAuthorities=dec.numberOfAuthorities,
                numberOfSubAccounts=dec.numberOfSubAccounts,
                lpCooldownTime=dec.lpCooldownTime,
                liquidationMarginBufferRatio=dec.liquidationMarginBufferRatio,
                settlementDuration=dec.settlementDuration,
                numberOfMarkets=dec.numberOfMarkets,
                numberOfSpotMarkets=dec.numberOfSpotMarkets,
                signerNonce=dec.signerNonce,
                minPerpAuctionDuration=dec.minPerpAuctionDuration,
                defaultMarketOrderTimeInForce=dec.defaultMarketOrderTimeInForce,
                defaultSpotAuctionDuration=dec.defaultSpotAuctionDuration,
                exchangeStatus=dec.exchangeStatus,
                liquidationDuration=dec.liquidationDuration,
                initialPctToLiquidate=dec.initialPctToLiquidate,
                maxNumberOfSubAccounts=dec.maxNumberOfSubAccounts,
                maxInitializeUserFee=dec.maxInitializeUserFee,
                padding=dec.padding,
                )

    def to_json(self) -> StateJSON:
        return {
                "admin": str(self.admin),
                "whitelistMint": str(self.whitelistMint),
                "discountMint": str(self.discountMint),
                "signer": str(self.signer),
                "srmVault": str(self.srmVault),
                "perpFeeStructure": self.perpFeeStructure.to_json(),
                "spotFeeStructure": self.spotFeeStructure.to_json(),
                "oracleGuardRails": self.oracleGuardRails.to_json(),
                "numberOfAuthorities": self.numberOfAuthorities,
                "numberOfSubAccounts": self.numberOfSubAccounts,
                "lpCooldownTime": self.lpCooldownTime,
                "liquidationMarginBufferRatio": self.liquidationMarginBufferRatio,
                "settlementDuration": self.settlementDuration,
                "numberOfMarkets": self.numberOfMarkets,
                "numberOfSpotMarkets": self.numberOfSpotMarkets,
                "signerNonce": self.signerNonce,
                "minPerpAuctionDuration": self.minPerpAuctionDuration,
                "defaultMarketOrderTimeInForce": self.defaultMarketOrderTimeInForce,
                "defaultSpotAuctionDuration": self.defaultSpotAuctionDuration,
                "exchangeStatus": self.exchangeStatus,
                "liquidationDuration": self.liquidationDuration,
                "initialPctToLiquidate": self.initialPctToLiquidate,
                "maxNumberOfSubAccounts": self.maxNumberOfSubAccounts,
                "maxInitializeUserFee": self.maxInitializeUserFee,
                "padding": self.padding,
                }

    @classmethod
    def from_json(cls, obj: StateJSON) -> "State":
        return cls(
                admin=SolPubkey.from_string(obj["admin"]),
                whitelistMint=SolPubkey.from_string(obj["whitelistMint"]),
                discountMint=SolPubkey.from_string(obj["discountMint"]),
                signer=SolPubkey.from_string(obj["signer"]),
                srmVault=SolPubkey.from_string(obj["srmVault"]),
                perpFeeStructure=types.feeStructure.FeeStructure.from_json(obj["perpFeeStructure"]),
                spotFeeStructure=types.feeStructure.FeeStructure.from_json(obj["spotFeeStructure"]),
                oracleGuardRails=types.oracleGuardRails.OracleGuardRails.from_json(obj["oracleGuardRails"]),
                numberOfAuthorities=obj["numberOfAuthorities"],
                numberOfSubAccounts=obj["numberOfSubAccounts"],
                lpCooldownTime=obj["lpCooldownTime"],
                liquidationMarginBufferRatio=obj["liquidationMarginBufferRatio"],
                settlementDuration=obj["settlementDuration"],
                numberOfMarkets=obj["numberOfMarkets"],
                numberOfSpotMarkets=obj["numberOfSpotMarkets"],
                signerNonce=obj["signerNonce"],
                minPerpAuctionDuration=obj["minPerpAuctionDuration"],
                defaultMarketOrderTimeInForce=obj["defaultMarketOrderTimeInForce"],
                defaultSpotAuctionDuration=obj["defaultSpotAuctionDuration"],
                exchangeStatus=obj["exchangeStatus"],
                liquidationDuration=obj["liquidationDuration"],
                initialPctToLiquidate=obj["initialPctToLiquidate"],
                maxNumberOfSubAccounts=obj["maxNumberOfSubAccounts"],
                maxInitializeUserFee=obj["maxInitializeUserFee"],
                padding=obj["padding"],
                )




